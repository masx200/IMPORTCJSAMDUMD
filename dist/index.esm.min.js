var t = (() => {
    let t;
    try {
        t = Function("u", "return import(u)");
    } catch (r) {
        t = async function(t) {
            if ("" === t) throw new TypeError("\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a");
            if ("string" != typeof t) throw new TypeError("\u53c2\u6570\u5fc5\u987b\u4e3a\u5b57\u7b26\u4e32");
            return t = new URL(t).href, await new Promise((r, e) => {
                function n() {
                    !function(t) {
                        try {
                            document.head.removeChild(t);
                        } catch (t) {}
                    }(a), function(t) {
                        try {
                            window.removeEventListener("error", t);
                        } catch (t) {}
                    }(o), URL.revokeObjectURL(a.src);
                }
                function o(t) {
                    e(t.error), n();
                }
                window.addEventListener("error", o);
                const i = function(t) {
                    return URL.createObjectURL(new Blob([ t ], {
                        type: "application/javascript"
                    }));
                }(`import*as m from'${t}';\nwindow[Symbol.for('${"import-" + t}')]=m`), a = document.createElement("script");
                a.type = "module", a.src = i, a.async = !0, document.head.appendChild(a), a.onload = () => {
                    r(window[Symbol.for("import-" + t)]), Reflect.deleteProperty(window, Symbol.for("import-" + t)), 
                    n();
                }, a.onerror = t => {
                    e(t), n();
                };
            });
        };
    }
    return t;
})();

const r = "PACKAGESTORE", e = "\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a", n = "\u52a0\u8f7d\u7684\u6a21\u5757\u6ca1\u6709\u8f93\u51fa", o = Symbol.for("name"), i = Symbol.for("url"), a = Symbol.for("source");

var f = (f, c) => {
    return u;
    function u(u, s) {
        return ((u, s) => {
            (async () => {
                try {
                    await (async () => {
                        let h;
                        try {
                            try {
                                h = await fetch(f).then(t => {
                                    if (!t.ok) throw new Error("fetch failed " + f);
                                    return t.text();
                                });
                            } catch (t) {
                                return void s(t);
                            }
                            try {
                                await (async h => {
                                    const m = {
                                        exports: {
                                            [Symbol.toStringTag]: "Module"
                                        }
                                    }, b = {
                                        exports: {}
                                    };
                                    var E;
                                    l.exports = {};
                                    const v = {
                                        default: void 0
                                    };
                                    try {
                                        !function(t, r, n, o, i) {
                                            const a = new Function("require", "define", "module", "exports", `"use strict";\n/* ${f} */;\n${i};\n/* ${f} */;\n`);
                                            E = a.toString(), a.call(n.exports, r => {
                                                if (w(r), "" === (r = String(r))) throw new TypeError(e);
                                                return r = function(t, r) {
                                                    return (String(r).startsWith("./") || String(r).startsWith("../")) && (String(r).endsWith(".js") || (r += ".js"), 
                                                    r = new URL(t + r).href), r;
                                                }(function(t) {
                                                    var r = new URL(t), e = r.pathname.split("/");
                                                    return e[e.length - 1] = "", r.origin + e.join("/");
                                                }(f), r), t(r);
                                            }, r, n, o.exports);
                                        }(y, l, b, m, h), function(t) {
                                            void 0 === t && (t = [ {}, {}, {} ]);
                                            void 0 === l.exports && (l.exports = {});
                                            function r(t) {
                                                return "object" != typeof t || Object.keys(t).length || "{}" !== JSON.stringify(t);
                                            }
                                            if (r(t[0])) {
                                                const r = t[0];
                                                p(v, r);
                                            } else if (r(t[1])) {
                                                const r = t[1];
                                                p(v, r);
                                            } else {
                                                if (!r(t[2])) return void s(Error(n + " " + c + " " + f));
                                                {
                                                    const r = t[2];
                                                    p(v, r);
                                                }
                                            }
                                        }([ m.exports ? m.exports : {}, b.exports ? b.exports : {}, l.exports ? l.exports : {} ]);
                                    } catch (r) {
                                        if (!(r instanceof SyntaxError)) return void s(r);
                                        {
                                            const r = f;
                                            E = r;
                                            try {
                                                const e = await t(r);
                                                p(v, e.default ? e.default : e);
                                            } catch (t) {
                                                return void s(t);
                                            }
                                            if (void 0 === v.default) return void s(Error(n + " " + c + " " + f));
                                        }
                                    }
                                    Object.defineProperties(v, {
                                        [o]: {
                                            value: c,
                                            writable: !0,
                                            enumerable: !1
                                        },
                                        [i]: {
                                            value: f,
                                            writable: !0,
                                            enumerable: !1
                                        },
                                        [a]: {
                                            value: E,
                                            enumerable: !1
                                        }
                                    }), "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(v, Symbol.toStringTag, {
                                        value: "Module"
                                    }), void 0 !== v.default && void 0 !== c && (d[r][c] = v), d[r][f] = d[r][c], v.default && Object.keys(v.default).filter(t => "default" !== t).forEach(t => {
                                        Object.defineProperty(v, t, {
                                            enumerable: !0,
                                            get: () => v.default[t]
                                        });
                                    }), u(v);
                                })(h);
                            } catch (t) {
                                return void s(t);
                            }
                        } catch (t) {
                            return void s(t);
                        }
                    })();
                } catch (t) {
                    return void s(t);
                }
            })();
        })(u, s);
    }
};

function c(t) {
    return "object" == typeof t && Array.isArray(t) && "[object Array]" === Object.prototype.toString.call(t);
}

const u = "\u53c2\u6570\u5fc5\u987b\u4e3a\u5b57\u7b26\u4e32", s = "\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a";

let y;

function l(t, r, e) {
    l.exports = {}, l.amd = !0;
    const n = [], o = Object.prototype.toString;
    var i;
    "string" != typeof t && (e = r, r = t, t = null), c(r) || (e = r, r = null), r || (i = e, 
    "[object Function]" !== o.call(i)) || (r = []), n.push([ t, r, e ]);
    const a = n[0][1].map(t => y(t));
    l.exports = n[0][2](...a);
}

function w(t) {
    if ("" === t) throw new TypeError(s);
    if ("string" != typeof t) throw new TypeError(u);
    return !0;
}

function p(t, r) {
    "Module" === r[Symbol.toStringTag] && r.default && (r = r.default), Object.defineProperty(t, "default", {
        enumerable: !0,
        get: () => r
    });
}

l.exports = {}, l.amd = !0;

const d = (() => {
    const t = "Cannot find module in packagestore, \u6a21\u5757\u4ed3\u5e93\u4e2d\u6ca1\u6709\u627e\u5230, ", r = "\u8f93\u5165\u7684\u7c7b\u578b\u9519\u8bef,\u8f93\u5165\u7684\u7c7b\u578b\u5fc5\u987b\u662f\u5b57\u7b26\u4e32\u6216\u8005\u6570\u7ec4\u6216\u5bf9\u8c61", e = "\u8f93\u5165\u7684\u7c7b\u578b\u9519\u8bef,\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a,url\u4e0d\u80fd\u4e3aundefined", n = "\u4f20\u5165\u7684\u53c2\u6570\u5fc5\u987b\u662f\u4e2aobject", o = Symbol.for("name"), i = Symbol.for("url"), a = "PACKAGESTORE", l = async function(...t) {
        const y = async function(t, u) {
            async function s(t) {
                return await Promise.all(Array.from(t).map(t => l(t[0], t[1])));
            }
            if (d(t)) return await (async t => {
                t = function(t) {
                    if ("object" != typeof t) throw new TypeError(n);
                    return JSON.parse(JSON.stringify(t));
                }(t);
                const r = Object.keys(t).map(r => {
                    const e = t[r], n = r;
                    return [ e, n ];
                });
                let e = [];
                try {
                    e = await s(r);
                } catch (t) {
                    e = await s(r);
                } finally {
                    e = await s(r);
                }
                let i = {};
                return e.forEach(t => {
                    i[t[o]] = t;
                }), i;
            })(t);
            if (c(t) && "object" == typeof t || "object" == typeof u) return await (async () => {
                let t = [];
                const r = Array(...arguments);
                try {
                    t = await s(r);
                } catch (e) {
                    t = await s(r);
                } finally {
                    t = await s(r);
                }
                return t;
            })();
            if ("string" == typeof t || "string" == typeof u) return w(t), await (async (t, r) => {
                if (void 0 === t || "" === t || "" === r) throw new TypeError(e);
                if (void 0 === r && (r = new URL(t).href), t = new URL(t).href, void 0 !== l[a][r] && void 0 !== l[a][r].default && l[a][r][i] === t) return p(r);
                if (void 0 !== l[a][t] && void 0 !== l[a][t].default && l[a][t][i] === t) return l[a][r] = l[a][t], 
                l[a][r][o] = r, p(t);
                {
                    const e = f(t, r);
                    return await new Promise(e);
                }
            })(t, u);
            throw new TypeError(r);
        }(...t);
        return await y.catch(async r => {
            if (!r.urlorname) throw r;
            if (function(t) {
                var r = !1;
                try {
                    if ("" === t) throw new TypeError(s);
                    if ("string" != typeof t) throw new TypeError(u);
                    t = new URL(t).href, r = !0;
                } catch (t) {
                    r = !1;
                }
                return r;
            }(r.urlorname)) await m(r.urlorname); else {
                if (!d(t[0]) || !Reflect.has(t[0], r.urlorname)) throw r;
                try {
                    await m(...t);
                } catch (t) {
                    throw r;
                }
            }
            return await m(...t);
        });
    };
    function p(r) {
        if ("" === r) throw new TypeError(s);
        if ("string" != typeof r) throw new TypeError(u);
        const e = l[a][r];
        if (e) return new Proxy(e, {
            set: () => !1,
            deleteProperty: () => !1
        });
        throw new Error(t + r);
    }
    function d(t) {
        return "object" == typeof t && "[object Object]" === Object.prototype.toString.call(t) && t.__proto__ === Object.prototype;
    }
    function h(t) {
        var r = false;
        try {
            if (t === "") {
                throw new TypeError(s);
            }
            if (typeof t !== "string") {
                throw new TypeError(u);
            }
            t = new URL(t).href;
            r = true;
        } catch (t) {
            r = false;
        }
        return r;
    }
    async function m(...t) {
        const r = b(...t);
        const e = async r => {
            if (r.urlorname) {
                if (h(r.urlorname)) {
                    undefined;
                    await m(r.urlorname);
                } else {
                    if (d(t[0]) && Reflect.has(t[0], r.urlorname)) {
                        try {
                            await m(...t);
                        } catch (t) {
                            undefined;
                            throw r;
                        }
                    } else {
                        throw r;
                    }
                }
            } else {
                throw r;
            }
            return await m(...t);
        };
        return await r.catch(e);
    }
    async function b(t, u) {
        function s(t) {
            if (typeof t !== "object") {
                throw new TypeError(n);
            }
            return JSON.parse(JSON.stringify(t));
        }
        async function y(t) {
            return await Promise.all(Array.from(t).map(t => {
                return l(t[0], t[1]);
            }));
        }
        if (d(t)) {
            return await (async t => {
                t = s(t);
                const r = Object.keys(t).map(r => {
                    const e = t[r];
                    const n = r;
                    return [ e, n ];
                });
                let e = [];
                try {
                    e = await y(r);
                } catch (t) {
                    undefined;
                    e = await y(r);
                } finally {
                    e = await y(r);
                }
                let n = {};
                e.forEach(t => {
                    n[t[o]] = t;
                });
                return n;
            })(t);
        } else if (c(t) && typeof t === "object" || typeof u === "object") {
            return await (async () => {
                let t = [];
                const r = Array(...arguments);
                try {
                    t = await y(r);
                } catch (e) {
                    undefined;
                    t = await y(r);
                } finally {
                    t = await y(r);
                }
                return t;
            })();
        } else if (typeof t === "string" || typeof u === "string") {
            w(t);
            return await (async (t, r) => {
                if (typeof t === "undefined" || t === "" || r === "") {
                    throw new TypeError(e);
                }
                if (typeof r === "undefined") {
                    r = new URL(t).href;
                }
                t = new URL(t).href;
                if (typeof l[a][r] !== "undefined" && typeof l[a][r].default !== "undefined" && l[a][r][i] === t) {
                    return p(r);
                } else if (typeof l[a][t] !== "undefined" && typeof l[a][t].default !== "undefined" && l[a][t][i] === t) {
                    l[a][r] = l[a][t];
                    l[a][r][o] = r;
                    return p(t);
                } else {
                    const e = f(t, r);
                    return await new Promise(e);
                }
            })(t, u);
        } else {
            throw new TypeError(r);
        }
    }
    return l.REQUIREPACKAGE = p, l[a] = l[a] || {}, y = function(r) {
        if ("" === r) throw new TypeError(s);
        if ("string" != typeof r) throw new TypeError(u);
        const e = l[a][r];
        if (e) return e.default;
        {
            let e = new Error(t + r);
            throw e.urlorname = r, e;
        }
    }, l;
})();

export default d;