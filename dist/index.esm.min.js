let t = (() => {
    let t;
    try {
        t = Function("u", "return import(u)");
    } catch (e) {
        t = async function(t) {
            if ("" === t) throw new TypeError("\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a");
            if ("string" != typeof t) throw new TypeError("\u53c2\u6570\u5fc5\u987b\u4e3a\u5b57\u7b26\u4e32");
            return t = new URL(t).href, await new Promise((e, r) => {
                const n = document.createElement("script");
                function o() {
                    !function(t) {
                        try {
                            document.head.removeChild(t);
                        } catch (t) {}
                    }(n), function(t) {
                        try {
                            window.removeEventListener("error", t);
                        } catch (t) {}
                    }(i), URL.revokeObjectURL(n.src);
                }
                function i(t) {
                    r(t.error), o();
                }
                window.addEventListener("error", i);
                const a = function(t) {
                    return URL.createObjectURL(new Blob([ t ], {
                        type: "application/javascript"
                    }));
                }(`import*as m from'${t}';\nwindow[Symbol.for('${"import-" + t}')]=m`);
                n.type = "module", n.src = a, n.async = !0, n.onload = () => {
                    e(window[Symbol.for("import-" + t)]), Reflect.deleteProperty(window, Symbol.for("import-" + t)), 
                    o();
                }, n.onerror = () => {
                    r(new Error("import load failed from network" + t)), o();
                }, document.head.appendChild(n);
            });
        };
    }
    return t;
})();

const e = "PACKAGESTORE", r = "\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a", n = "\u52a0\u8f7d\u7684\u6a21\u5757\u6ca1\u6709\u8f93\u51fa", o = Symbol.for("name"), i = Symbol.for("url"), a = Symbol.for("source");

var c = (c, f) => {
    return new Promise(function(u, s) {
        return ((u, s) => {
            (async () => {
                try {
                    await (async () => {
                        let y;
                        try {
                            try {
                                y = await fetch(c).then(t => {
                                    if (!t.ok) throw new Error("fetch failed " + c);
                                    return t.text();
                                });
                            } catch (t) {
                                return void s(t);
                            }
                            try {
                                await (async y => {
                                    let l;
                                    const w = {
                                        exports: {
                                            [Symbol.toStringTag]: "Module"
                                        }
                                    }, p = {
                                        exports: {}
                                    };
                                    var d;
                                    g.exports = {};
                                    const h = {
                                        default: void 0
                                    };
                                    try {
                                        !function(t, e, n, o, i) {
                                            const a = new Function("require", "define", "module", "exports", `"use strict";\n/* ${c} */;\n${i};\n/* ${c} */;\n`);
                                            d = a.toString(), a.call(n.exports, e => {
                                                if (v(e), "" === (e = String(e))) throw new TypeError(r);
                                                const n = function(t) {
                                                    var e = new URL(t), r = e.pathname.split("/");
                                                    return r[r.length - 1] = "", e.origin + r.join("/");
                                                }(c);
                                                return e = function(t, e) {
                                                    (String(e).startsWith("./") || String(e).startsWith("../")) && (String(e).endsWith(".js") || (e += ".js"), 
                                                    e = new URL(t + e).href);
                                                    return e;
                                                }(n, e), t(e);
                                            }, e, n, o.exports);
                                        }(E, g, p, w, y);
                                        const e = [ w.exports ? w.exports : {}, p.exports ? p.exports : {}, g.exports ? g.exports : {} ];
                                        !function(t) {
                                            void 0 === t && (t = [ {}, {}, {} ]);
                                            void 0 === g.exports && (g.exports = {});
                                            function e(t) {
                                                return "object" != typeof t || Object.keys(t).length || "{}" !== JSON.stringify(t);
                                            }
                                            if (e(t[0])) {
                                                const e = t[0];
                                                j(h, e);
                                            } else if (e(t[1])) {
                                                const e = t[1];
                                                j(h, e);
                                            } else {
                                                if (!e(t[2])) return void s(Error(n + " " + f + " " + c));
                                                {
                                                    const e = t[2];
                                                    j(h, e);
                                                }
                                            }
                                        }(e), l = "cjs";
                                    } catch (e) {
                                        if (!(e instanceof SyntaxError)) return void s(e);
                                        {
                                            const e = c;
                                            d = y;
                                            try {
                                                const r = await t(e);
                                                l = "esm", Object.keys(r).filter(t => "default" !== t).forEach(t => {
                                                    Object.defineProperty(h, t, {
                                                        enumerable: !0,
                                                        get: () => r[t]
                                                    });
                                                }), j(h, r.default ? r.default : r);
                                            } catch (t) {
                                                return void s(t);
                                            }
                                            if (void 0 === h.default) return void s(Error(n + " " + f + " " + c));
                                        }
                                    }
                                    Object.defineProperties(h, {
                                        [o]: {
                                            value: f,
                                            writable: !0,
                                            enumerable: !1
                                        },
                                        [i]: {
                                            value: c,
                                            enumerable: !1
                                        },
                                        [a]: {
                                            value: d,
                                            enumerable: !1
                                        },
                                        [Symbol.for("type")]: {
                                            value: l,
                                            enumerable: !1
                                        }
                                    }), "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(h, Symbol.toStringTag, {
                                        value: "Module"
                                    }), void 0 !== h.default && void 0 !== f && (S[e][f] = h), S[e][c] = S[e][f], h.default && Object.keys(h.default).filter(t => "default" !== t).forEach(t => {
                                        try {
                                            Object.defineProperty(h, t, {
                                                enumerable: !0,
                                                get: () => h.default[t]
                                            });
                                        } catch (t) {}
                                    }), u(h);
                                })(y);
                            } catch (t) {
                                return void s(t);
                            }
                        } catch (t) {
                            return void s(t);
                        }
                    })();
                } catch (t) {
                    return void s(t);
                }
            })();
        })(u, s);
    });
};

const f = "\u4f20\u5165\u7684\u53c2\u6570\u5fc5\u987b\u662f\u4e2aobject", u = "Cannot find module in packagestore, \u6a21\u5757\u4ed3\u5e93\u4e2d\u6ca1\u6709\u627e\u5230, ";

function s(t) {
    if ("object" != typeof t) throw new TypeError(f);
    return JSON.parse(JSON.stringify(t));
}

async function y(t) {
    return await Promise.all(Array.from(t).map(t => S(t[0], t[1])));
}

function l(t) {
    var e = !1;
    try {
        if ("" === t) throw new TypeError(b);
        if ("string" != typeof t) throw new TypeError(m);
        t = new URL(t).href, e = !0;
    } catch (t) {
        e = !1;
    }
    return e;
}

function w(t) {
    return "object" == typeof t && Array.isArray(t) && "[object Array]" === Object.prototype.toString.call(t);
}

function p(t) {
    if ("" === t) throw new TypeError(b);
    if ("string" != typeof t) throw new TypeError(m);
    const e = S[d][t];
    if (e) return new Proxy(e, {
        set: () => !1,
        deleteProperty: () => !1
    });
    throw new Error(u + t);
}

const d = "PACKAGESTORE";

function h(t) {
    return "object" == typeof t && "[object Object]" === Object.prototype.toString.call(t) && t.__proto__ === Object.prototype;
}

const m = "\u53c2\u6570\u5fc5\u987b\u4e3a\u5b57\u7b26\u4e32", b = "\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a";

let E = function(t) {
    if ("" === t) throw new TypeError(b);
    if ("string" != typeof t) throw new TypeError(m);
    const e = S[d][t];
    if (e) return e.default;
    {
        let e = new Error(u + t);
        throw e.urlorname = t, e;
    }
};

function g(t, e, r) {
    g.exports = {}, g.amd = !0;
    const n = [];
    "string" != typeof t && (r = e, e = t, t = null), w(e) || (r = e, e = null), !e && function(t) {
        const e = Object.prototype.toString;
        return "function" == typeof t && "[object Function]" === e.call(t);
    }(r) && (e = []), n.push([ t, e, r ]);
    const o = n[0][1].map(t => E(t));
    g.exports = n[0][2](...o);
}

function v(t) {
    if ("" === t) throw new TypeError(b);
    if ("string" != typeof t) throw new TypeError(m);
    return !0;
}

function j(t, e) {
    "Module" === e[Symbol.toStringTag] && e.default && (e = e.default), Object.defineProperty(t, "default", {
        enumerable: !0,
        get: () => e
    });
}

g.exports = {}, g.amd = !0;

const S = (() => {
    const t = "\u8f93\u5165\u7684\u7c7b\u578b\u9519\u8bef,\u8f93\u5165\u7684\u7c7b\u578b\u5fc5\u987b\u662f\u5b57\u7b26\u4e32\u6216\u8005\u6570\u7ec4\u6216\u5bf9\u8c61", e = "\u8f93\u5165\u7684\u7c7b\u578b\u9519\u8bef,\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u4e0d\u80fd\u4e3a\u7a7a,url\u4e0d\u80fd\u4e3aundefined", r = Symbol.for("name"), n = Symbol.for("url"), o = async function(...a) {
        const u = async function(i, a) {
            if (h(i)) return await (async t => {
                t = function(t) {
                    if ("object" != typeof t) throw new TypeError(f);
                    return JSON.parse(JSON.stringify(t));
                }(t);
                const e = Object.keys(t).map(e => {
                    const r = t[e], n = e;
                    return [ r, n ];
                });
                let n = [];
                try {
                    n = await y(e);
                } catch (t) {
                    n = await y(e);
                } finally {
                    n = await y(e);
                }
                let o = {};
                return n.forEach(t => {
                    o[t[r]] = t;
                }), o;
            })(i);
            if (w(i) && "object" == typeof i || "object" == typeof a) return await (async () => {
                let t = [];
                const e = Array(...arguments);
                try {
                    t = await y(e);
                } catch (r) {
                    t = await y(e);
                } finally {
                    t = await y(e);
                }
                return t;
            })();
            if ("string" == typeof i || "string" == typeof a) return v(i), await (async (t, i) => {
                if (void 0 === t || "" === t || "" === i) throw new TypeError(e);
                return void 0 === i && (i = new URL(t).href), t = new URL(t).href, void 0 !== o[d][i] && void 0 !== o[d][i].default && o[d][i][n] === t ? p(i) : void 0 !== o[d][t] && void 0 !== o[d][t].default && o[d][t][n] === t ? (o[d][i] = o[d][t], 
                o[d][i][r] = i, p(t)) : await c(t, i);
            })(i, a);
            throw new TypeError(t);
        }(...a);
        return await u.catch(async t => {
            if (!t.urlorname) throw t;
            if (function(t) {
                var e = !1;
                try {
                    if ("" === t) throw new TypeError(b);
                    if ("string" != typeof t) throw new TypeError(m);
                    t = new URL(t).href, e = !0;
                } catch (t) {
                    e = !1;
                }
                return e;
            }(t.urlorname)) await i(t.urlorname); else {
                if (!h(a[0]) || !Reflect.has(a[0], t.urlorname)) throw t;
                try {
                    await i(...a);
                } catch (e) {
                    throw t;
                }
            }
            return await i(...a);
        });
    };
    async function i(...t) {
        const e = a(...t);
        const r = async e => {
            if (e.urlorname) {
                if (l(e.urlorname)) {
                    undefined;
                    await i(e.urlorname);
                } else {
                    if (h(t[0]) && Reflect.has(t[0], e.urlorname)) {
                        try {
                            await i(...t);
                        } catch (t) {
                            undefined;
                            throw e;
                        }
                    } else {
                        throw e;
                    }
                }
            } else {
                throw e;
            }
            return await i(...t);
        };
        return await e.catch(r);
    }
    async function a(i, a) {
        if (h(i)) {
            return await (async t => {
                t = s(t);
                const e = Object.keys(t).map(e => {
                    const r = t[e];
                    const n = e;
                    return [ r, n ];
                });
                let n = [];
                try {
                    n = await y(e);
                } catch (t) {
                    undefined;
                    n = await y(e);
                } finally {
                    n = await y(e);
                }
                let o = {};
                n.forEach(t => {
                    o[t[r]] = t;
                });
                return o;
            })(i);
        } else if (w(i) && typeof i === "object" || typeof a === "object") {
            return await (async () => {
                let t = [];
                const e = Array(...arguments);
                try {
                    t = await y(e);
                } catch (r) {
                    undefined;
                    t = await y(e);
                } finally {
                    t = await y(e);
                }
                return t;
            })();
        } else if (typeof i === "string" || typeof a === "string") {
            v(i);
            return await (async (t, i) => {
                if (typeof t === "undefined" || t === "" || i === "") {
                    throw new TypeError(e);
                }
                if (typeof i === "undefined") {
                    i = new URL(t).href;
                }
                t = new URL(t).href;
                if (typeof o[d][i] !== "undefined" && typeof o[d][i].default !== "undefined" && o[d][i][n] === t) {
                    return p(i);
                } else if (typeof o[d][t] !== "undefined" && typeof o[d][t].default !== "undefined" && o[d][t][n] === t) {
                    o[d][i] = o[d][t];
                    o[d][i][r] = i;
                    return p(t);
                } else {
                    return await c(t, i);
                }
            })(i, a);
        } else {
            throw new TypeError(t);
        }
    }
    return o[d] = o[d] || {}, o.REQUIREPACKAGE = p, o;
})();

export default S;