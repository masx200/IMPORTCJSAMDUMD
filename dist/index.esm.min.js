class t extends Error{constructor(t,e){super(t),this.urlorname=e}}function e(t){if(""===t)throw new TypeError(T);if("string"!=typeof t)throw new TypeError(L)}function n(n){e(n);const r=U[n];if(r)return Object.freeze(r),r;throw new t(R+n,n)}function r(t){return"object"==typeof t&&"[object Object]"==={}.toString.call(t)&&t instanceof Object}async function o(t,e){return await Promise.all(t.map(t=>e(t)))}async function a(t,e){return await Promise.all(t.map(t=>e(t[0],t[1])))}const i={};const c=(()=>{let t;try{t=Function("u","return import(u)")}catch(n){t=async function(t){return e(t),t=new URL(t).href,await function(t){const e=Symbol.for("import-"+t);return new Promise((n,r)=>{const o=document.createElement("script");function a(){o.remove(),function(t){try{window.removeEventListener("error",t)}catch(t){}}(i),URL.revokeObjectURL(o.src),o.onload=o.onerror=null}function i(t){r(t.error),a()}window.addEventListener("error",i);const c=function(t){return URL.createObjectURL(new Blob([t],{type:"application/javascript"}))}(`import*as m from'${t}';\nwindow[Symbol.for('${"import-"+t}')]=m`);o.type="module",o.src=c,o.async=!0,o.onload=()=>{if(Reflect.has(window,e)){const t=p(window,e);n(t),h(window,e,void 0),a()}},o.onerror=()=>{r(new Error("import load failed from network"+t)),a()},document.head.appendChild(o)})}(t)}}return t})();const u=function(n){e(n);const r=U[n];if(r)return Object.freeze(r),r.default?r.default:r;throw new t(R+n,n)},s=(t,n)=>{e(t);const r=function(t,e){return(String(e).startsWith("./")||String(e).startsWith("../"))&&(String(e).endsWith(".js")||e.endsWith(".mjs")||e.endsWith(".json")||e.endsWith(".css")||e.endsWith(".html")||(e+=".js"),e=new URL(t+e).href),e}(function(t){var e=new URL(t),n=e.pathname.split("/");return n[n.length-1]="",e.origin+n.join("/")}(n),t);return u(r)};function f(t){return Array.isArray(t)&&"[object Array]"==={}.toString.call(t)}function l(t){const e={}.toString.call(t);return"function"==typeof t&&"[object Function]"===e||"[object AsyncFunction]"===e}function y(t,e,n){y.exports={},y.amd=!0,"string"!=typeof t&&(n=e,e=t,t=null),f(e)||(n=e,e=null),!e&&l(n)&&(e=[]);const r=[t,e,n],o=r[1].map(t=>u(t));y.exports=r[2](...o)}function d(t){return!("object"==typeof t&&!Object.keys(t).length&&"{}"===JSON.stringify(t))}function w(t,e){e&&(l(e)||"object"==typeof e)&&Object.keys(e).forEach(n=>{try{m(t,n,{enumerable:!0,get:()=>p(e,n)})}catch(t){}})}y.exports={},y.amd=!0;const{get:p,set:h,defineProperty:m}=Reflect,b=Symbol("type"),g=Symbol("name"),v=Symbol("url"),j=Symbol("source");var S=async(t,e)=>{return await new Promise((function(n,o){return((n,o)=>(async()=>{try{return await(async()=>{let a;try{try{a=await async function(t){const e=p(i,t);if(e)return e;{const e=await fetch(t).then(async e=>{if(!e.ok)throw new Error("fetch failed "+t);return await e.text()});return h(i,t,e),e}}(t)}catch(t){return void o(t)}try{return await(async a=>{let i;const u={[Symbol.toStringTag]:"Module"},f={exports:{[Symbol.toStringTag]:"Module"}};let l;y.exports={};const h=Object.assign(Object.create(null),{default:void 0});try{!function(){const e=new Function("require","define","module","exports",`"use strict";\n/* ${t} */;\n${a};\n/* ${t} */;\n`);l=e.toString(),e.call(f.exports,e=>s(e,t),y,f,u)}();const e=function(t,e,n){if(void 0===y.exports&&(y.exports={}),d(t[0])){return t[0]}if(d(t[1])){return t[1]}if(d(t[2])){return t[2]}}([u||{},f.exports?f.exports:{},y.exports?y.exports:{}]);i="cjs",e&&(!function(t,e){var n;e=p(e,"default")?p(e,"default"):e,n=e,"[object Module]"==={}.toString.call(n)||r(e)||m(t,"default",{enumerable:!0,get:()=>e})}(h,e),w(h,e))}catch(e){try{const t=JSON.parse(a);l=a,i="json",w(h,t)}catch(n){if(!(e instanceof SyntaxError))return void o(e);{const e=t;l=a;try{const t=await c(e);i="esm",w(h,t)}catch(t){return void o(t)}if(void 0===h.default)try{m(h,"default",{value:void 0,enumerable:!1})}catch{}}}}if(Object.defineProperties(h,{[g]:{value:e},[v]:{value:t},[j]:{value:l},[b]:{value:i}}),"undefined"!=typeof Symbol&&Symbol.toStringTag&&m(h,Symbol.toStringTag,{value:"Module"}),void 0!==e&&(U[e]=h),void 0!==e&&(U[t]=U[e]),h.default&&w(h,h.default),void 0===h.default)try{m(h,"default",{value:void 0,enumerable:!1})}catch(t){}Object.freeze(h),n(h)})(a)}catch(t){return void o(t)}}catch(t){return void o(t)}})()}catch(t){return void o(t)}})())(n,o)}))};const O="The type entered is incorrect, the type entered must be a string or an array or an object",x="The argument passed in must be an object";async function E(t,i){if(r(t))return await(async t=>{t=function(t){if("object"!=typeof t)throw new TypeError(x);return JSON.parse(JSON.stringify(t))}(t);const e=Object.entries(t).map(([t,e])=>[e,t]);let n=[];try{n=await a(e,E)}catch(t){n=await a(e,E)}finally{n=await a(e,E)}let r={};return n.forEach(t=>{r[t[g]]=t}),r})(t);if(f(t))return await(async(...t)=>{let e=[];const n=t;try{e=await o(n,E)}catch(t){e=await o(n,E)}finally{e=await o(n,E)}return e})(...t);if("string"==typeof t||"string"==typeof i)return e(t),await(async(t,e)=>(void 0===e&&(e=new URL(t).href),t=new URL(t).href,void 0!==U[e]&&void 0!==U[e].default&&p(U[e],v)===t?n(e):void 0!==U[t]&&void 0!==U[t].default&&p(U[t],v)===t?(U[e]=U[t],h(U[e],g,e),n(t)):await S(t,e)))(t,i);throw new TypeError(O)}const R="Cannot find module in packagestore, Not found in module repository, ",L="Parameter must be a string",T="String cannot be empty";const U={},N=n;export default async function(n,o){let a=0;return await E(n,o).catch(c);async function i(t,e,n,r){try{return await E(t,e).catch(c),await E(n,r)}catch(t){return await E(n,r).catch(c)}}async function c(c){if(a>100)throw new Error("Try loading, too many failures, give up trying!"+JSON.stringify(n)+JSON.stringify(o));if(a++,c instanceof t){const t=c.urlorname;if(function(t){var n=!1;try{e(t),t=new URL(t).href,n=!0}catch(t){n=!1}return n}(t))return await i(t,void 0,n,o);if(r(n)&&Reflect.has(n,t))return await i(p(n,t),t,n,o);throw c}throw c}}export{U as PACKAGESTORE,N as REQUIREPACKAGE};
//# sourceMappingURL=index.esm.min.js.map
