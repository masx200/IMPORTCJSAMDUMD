class t extends Error{constructor(t,r){super(t),this.urlorname=r}}function r(t){if(""===t)throw new TypeError(N);if("string"!=typeof t)throw new TypeError(M)}const e=Object.create(null);function n(n){r(n);const o=P[n]||P[e[n]];if(o)return Object.freeze(o),o;throw new t($+n,n)}function o(t){var e=!1;try{r(t),t=new URL(t).href,e=!0}catch(t){e=!1}return e}async function i(t,r){return await Promise.all(t.map(t=>r(t)))}function c(t){return t.map(t=>{var r;return o(t)?t:null!==(r=e[t])&&void 0!==r?r:t})}const a=Object.create(null);function s(t){const r={}.toString.call(t);return"function"==typeof t&&"[object Function]"===r||"[object AsyncFunction]"===r}const u=Object.getPrototypeOf((async function(){})).constructor;const l=Object.create(null),f=Object.create(null);function y(t,r){var e,n,o;r=null!==(e=R(r,"default"))&&void 0!==e?e:r,o=r,"[object Module]"==={}.toString.call(o)||"object"==typeof(n=r)&&"[object Object]"==={}.toString.call(n)&&n instanceof Object||W(t,"default",{enumerable:!0,get:()=>r})}function d(t){return Array.isArray(t)&&"[object Array]"==={}.toString.call(t)}const w=(()=>{let t;try{t=Function("u","return import(u)")}catch(e){t=async function(t){return r(t),t=new URL(t).href,await function(t){const r=Symbol.for("import-"+t);return new Promise((e,n)=>{const o=document.createElement("script");function i(){o.remove(),function(t){try{window.removeEventListener("error",t)}catch(t){}}(c),URL.revokeObjectURL(o.src),o.onload=o.onerror=null}function c(t){n(t.error),i()}window.addEventListener("error",c);const a=(s=`import*as m from'${t}';\nwindow[Symbol.for('${"import-"+t}')]=m`,URL.createObjectURL(new Blob([s],{type:"application/javascript"})));var s;o.type="module",o.src=a,o.async=!0,o.onload=()=>{if(Reflect.has(window,r)){const t=R(window,r);e(t),U(window,r,void 0),i()}},o.onerror=()=>{n(new Error("import load failed from network"+t)),i()},document.head.appendChild(o)})}(t)}}return t})();function h(t,r){r&&(s(r)||"object"==typeof r)&&Object.keys(r).forEach(e=>{try{W(t,e,{enumerable:!0,get:()=>R(r,e)})}catch(t){}})}const p=function(n){var o;r(n);const i=P[n]||P[e[n]];if(i)return Object.freeze(i),null!==(o=i.default)&&void 0!==o?o:i;throw new t($+n,n)};function m(t,r){if(String(t).startsWith("./")||String(t).startsWith("../")){return function(t,r){return(String(r).startsWith("./")||String(r).startsWith("../"))&&(String(r).endsWith(".js")||r.endsWith(".mjs")||r.endsWith(".json")||r.endsWith(".css")||r.endsWith(".html")||(r+=".js"),r=new URL(t+r).href),r}(function(t){var r=new URL(t);return new URL(".",r.href).href}(r),t)}return t}function g(t){return!("object"==typeof t&&!Object.keys(t).length&&"{}"===JSON.stringify(t))}const b=Symbol("deps"),v=Symbol("type"),j=Symbol("url");var S=/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*(["'])(.+?)\1\s*\)/g,O=/\\\\/g;const E=Object.create(null);function L(t){return[...new Set(t)]}const{get:R,set:U,defineProperty:W}=Reflect;var x=async t=>{if(a[t])return await a[t].promise;{const e=function(){let t=()=>{},r=()=>{},e=new Promise((e,n)=>{t=e,r=n});return{resolve:t,reject:r,promise:e}}();a[t]=e;try{const n=await new Promise((async function(e,n){var o;try{let T,k;try{try{[T,k]=await async function(t){let r;const e=R(l,t),n=R(f,t);if(e&&n)return[e,n];{const e=await fetch(t);if(!e.ok)throw new Error("fetch failed "+t);const n=e.headers.get("content-type");if(null==n?void 0:n.includes("javascript"))r="js";else{if(null==n||!n.includes("json"))throw new Error("invalid content-type "+n);r="json"}const o=await e.text();return U(l,t,o),U(f,t,r),[o,r]}}(t)}catch(t){return void n(t)}const $=Object.create(null);let M;$[j]=t;const N=T;if("undefined"!=typeof Symbol&&Symbol.toStringTag&&W($,Symbol.toStringTag,{value:"Module"}),$[b]=[],"json"===k){const r=JSON.parse(N);return M="json",h($,r),$[v]=M,Object.freeze($),P[t]=$,void e($)}if("js"!==k)throw new Error("invalid codetype "+k);try{const l={[Symbol.toStringTag]:"Module"},f={exports:{[Symbol.toStringTag]:"Module"}};try{let e=!1;const n=null!==(o=R(E,t))&&void 0!==o?o:new u("require","exports","module","define",`                        "use strict";\n/* ${t} */;\n;${N};\n;/* ${t} */;\n                        `);U(E,t,n),$[b]=L(c((a=N,x=[],a.replace(O,"").replace(S,(function(t,r,e,...n){return e&&x.push(e),""})),x).map(r=>m(r,t)))),await z($[b]);let w=()=>{};const v=e=>((t,e)=>{if(r(t),String(t).startsWith("./")||String(t).startsWith("../")){const r=m(t,e);return p(r)}return p(t)})(e,t),j=(r,n,o)=>{const i=function(t,r,e){return"string"!=typeof t&&(e=r,r=t,t=null),d(r)||(e=r,r=null),r||(r=[]),[t,r,e]}(r,n,o);e=!0,w=i[2],$[b]=L(c(i[1].map(r=>m(r,t))))};if(Object.assign(j,{amd:!0,cmd:!0}),await n.call(f.exports,v,l,f,j),e){let t,r;M="amd",await z($[b]),t=$[b].length?$[b].map(t=>p(t)):[v,l,f],s(w)?r=w.call(f.exports,...t):(i=w)&&"object"==typeof i&&(r=w),r=await r,r&&(f.exports=r)}else M="cjs";!f.exports&&(f.exports={[Symbol.toStringTag]:"Module"});const W=[l,f.exports],T=await function(t){if(g(t[0])){return t[0]}if(g(t[1])){return t[1]}}(W);T&&(y($,T),h($,T))}catch(r){if(!(r instanceof SyntaxError))return void n(r);{const r=t;try{const t=await w(r);$[b]=[],M="esm",h($,t)}catch(t){return void n(t)}}}return $[v]=M,P[t]=$,$.default&&h($,$.default),Object.freeze($),void e($)}catch(t){return void n(t)}}catch(t){return void n(t)}}catch(t){return void n(t)}var i;var a,x}));return e.resolve(n),n}catch(t){throw e.reject(t),t}}};async function T(t,o){var c;if(d(t))return await(async(...t)=>{let r=[];const e=t;try{r=await i(e,T)}catch(t){r=await i(e,T)}finally{r=await i(e,T)}return r})(...t);if("string"==typeof t||"string"==typeof o){r(t);try{t=new URL(t).href}catch{t=null!==(c=e[t])&&void 0!==c?c:t}return await(async(t,r)=>{if(String(t).startsWith("./")||String(t).startsWith("../")){var o=new URL(t,location.href);t=o.origin+o.pathname}try{t=new URL(t).href}catch{throw Error("invalid url "+t)}return void 0===r&&(r=new URL(t).href),r&&(e[r]=t),void 0!==P[r]&&R(P[r],j)===t?n(r):void 0!==P[t]&&R(P[t],j)===t?n(t):await x(t)})(t,o)}throw new TypeError("The type entered is incorrect, the type entered must be a string or an array ")}const P=Object.create(null),k=n,$="Cannot find module in packagestore, Not found in module repository, ",M="Parameter must be a string",N="String cannot be empty";async function z(r,e){let n=0;return await T(r,e).catch(i);async function i(c){if(n>5)throw new Error("Try loading, too many failures, give up trying!"+JSON.stringify(r)+JSON.stringify(e));if(n++,c instanceof t){const t=c.urlorname;if(o(t))return await async function(t,r,e,n){try{return await T(t,r).catch(i),await T(e,n)}catch(t){return await T(e,n).catch(i)}}(t,void 0,r,e);throw c}throw c}}export{l as cachedurltotext,E as cacheurltocjsfun,z as importcjsamdumd,e as packagealias,P as packagestore,k as requirepackage};
//# sourceMappingURL=index.min.js.map
