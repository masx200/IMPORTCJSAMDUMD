{"version":3,"sources":["../node_modules/regenerator-runtime/runtime.js","点击链接不跳转-修改当前的网页地址-动态加载网页内容不刷新.js"],"names":["global","windowloadhandler","alreadyrun","loadid","console","log","document","write","t","warn","window","removeEventListener","htmldataboject","Object","Array","querySelectorAll","forEach","e","href","src","firstElementChild","dataset","search","location","pathname","替换a链接","addEventListener","替换a链接数组","onpopstatehandler","动态加载网页内容不刷新","script完成数量","script总数量","script加载完成","完成linkstylesheet","数量linkstylesheet","单个stylesheet加载完成","requestAnimationFrame","from","getElementsByTagName","替换所有a链接的arrayhandler","contentDocument","length","protocol","hostname","push","name","text","outerHTML","url","URL","origin","history","pushState","undefined","dispatchEvent","PopStateEvent","urlortext","scrollTo","Event","所有文本内容加载的脚本完成","setTimeout","loadscript","fileurl","loadguid","guid","callback","errorcallback","script","createElement","type","onload","async","onerror","appendChild","loadscripttext","innerHTML","loadstylesheet","rel","replace","Math","random","toString","失败StyleSheet","失败scriptsrc","protocal","fetch","style","className","onallscriptloadformsrchandler","script文本内容数组","添加文本script元素数组","allstyleloadhandler","删除旧元素数组","parentNode","removeChild","dataresponse","open","ok","status","arrayBuffer","arraybuffer","datacontenttype","headers","get","toLowerCase","includes","myhtmlcharset","slice","indexOf","charsetelement","DOMParser","parseFromString","TextDecoder","decode","getAttribute","error","dataContentType","sr","myhtmldata","mynewhtmldataurl","decodeURI","title","charset","添加stylesheet元素到head数组","添加元素到head数组","添加script元素数组","module","exports","修改当前的网页地址动态加载网页内容不刷新","同源网址跳转动态加载"],"mappings":"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","file":"点击链接不跳转-修改当前的网页地址-动态加载网页内容不刷新.js","sourceRoot":"..\\src","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","//由于使用了async函数所以需要regeneratorRuntime\r\n// import IMPORTCJSAMDUMD from \"./IMPORTCJSAMDUMD\";\r\nimport regeneratorRuntime from \"regenerator-runtime\";\r\n// console.log(regeneratorRuntime)\r\n\r\n/**点击链接不跳转修改当前的网页地址动态加载网页内容不刷新 */\r\n(global => {\r\n  /**点击链接不跳转修改当前的网页地址动态加载网页内容不刷新 */\r\n  /* 注意不能跨域 */\r\n  /* 注意:对于使用了document.write的网站, 加载会出错,因为脚本都是异步加载的,网页内容会被覆盖\r\n    修改了document.write方法\r\n    */\r\n  /* var 平滑滚动css = document.createElement(\"style\");\r\n    平滑滚动css.innerHTML = ` body {\r\n          scroll-behavior: smooth;\r\n        }\r\n        html {\r\n          scroll-behavior: smooth;\r\n        }`;\r\n    document.firstElementChild.firstElementChild.appendChild(平滑滚动css); */\r\n\r\n  /**  执行顺序\r\n   * 1.开始发起fetch请求 url\r\n   * 2.获取返回头部的编码信息和文件类型信息,如果这里没有编码信息,则在转成文字之后查找meta中charset和meta的Content-Type中的charset\r\n   * 3.把返回的arraybuffer解码成文字,然后转成html的document对象\r\n   * 4.复制接收的html的body的内容到当前网页的body当中\r\n   * 5.添加其他标签到head中,不包括stylesheet和script\r\n   * 6.1.线程1-添加有href的link的stylesheet到head中,当他们加载完成时,触发window的allstylesheetload事件,然后删除旧的stylesheet和script元素 和其他元素\r\n   * 6.2.线程2-添加有src的script的javascript到head中,当他们加载完成时,触发window的allscriptloadformsrc事件,加载用文本内容加载的javascript到head执行,触发\"alltextscriptload\"事件,然后再触发window的load事件\r\n   *\r\n   */\r\n  if (\"object\" == typeof module && \"object\" == typeof module.exports) {\r\n    module.exports = windowloadhandler;\r\n  }\r\n  if (typeof 修改当前的网页地址动态加载网页内容不刷新 !== \"function\") {\r\n    window.addEventListener(\"load\", windowloadhandler);\r\n  }\r\n  /**\r\n   * 防止多次加载windowloadhandler\r\n   *\r\n   *   *\r\n   */\r\n  global.修改当前的网页地址动态加载网页内容不刷新 =   global.修改当前的网页地址动态加载网页内容不刷新||windowloadhandler;\r\n\r\n  function 同源网址跳转动态加载(url = location.href) {\r\n    url = new URL(url);\r\n    /* 替换协议与当前网页相同的协议 */\r\n    url.protocol = location.protocol;\r\n    if (\r\n      (url.origin === location.origin && url.pathname !== location.pathname) ||\r\n      url.search !== location.search\r\n    ) {\r\n      history.pushState(undefined, undefined, url);\r\n      window.dispatchEvent(new PopStateEvent(\"popstate\"));\r\n    }\r\n  }\r\n  windowloadhandler.同源网址跳转动态加载 = 同源网址跳转动态加载;\r\n  windowloadhandler.alreadyrun = 0;\r\n\r\n  function windowloadhandler() {\r\n    if (windowloadhandler.alreadyrun != 1) {\r\n      windowloadhandler.alreadyrun = 1;\r\n      console.log(\r\n        \"第一次运行此函数启动,点击链接不跳转,修改当前的网页地址,动态加载网页内容,不刷新\"\r\n      );\r\n    } else {\r\n      console.log(\"已经运行过此函数,不能再次运行\");\r\n      return;\r\n    }\r\n\r\n    var loadid;\r\n    // IMPORTCJSAMDUMD(\r\n    //   \"https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\"\r\n    // ).then(module => {\r\n    //   var jQuery = module.default;\r\n\r\n    // if (!importScripts) {\r\n    /* var importScripts = (function(globalEval) {\r\n      var xhr = new XMLHttpRequest();\r\n      return function importScripts() {\r\n        var args = Array.prototype.slice.call(arguments),\r\n          len = args.length,\r\n          i = 0,\r\n          meta,\r\n          data,\r\n          content;\r\n        for (; i < len; i++) {\r\n          if (args[i].substr(0, 5).toLowerCase() === \"data:\") {\r\n            data = args[i];\r\n            content = data.indexOf(\",\");\r\n            meta = data.substr(5, content).toLowerCase();\r\n            data = decodeURIComponent(data.substr(content + 1));\r\n            if (/;\\s*base64\\s*[;,]/.test(meta)) {\r\n              data = atob(data);\r\n            }\r\n            if (/;\\s*charset=[uU][tT][fF]-?8\\s*[;,]/.test(meta)) {\r\n              data = decodeURIComponent(escape(data));\r\n            }\r\n          } else {\r\n            xhr.open(\"GET\", args[i], false);\r\n            xhr.send(null);\r\n            data = xhr.responseText;\r\n          }\r\n          globalEval(data);\r\n        }\r\n      };\r\n    })(eval); */\r\n    // }\r\n    //   if (\"function\" == typeof jQuery) {\r\n    //     console.log(\"当前的jquery版本号为\" + jQuery.fn.jquery);\r\n    //   }\r\n    /* new Promise(resolve => {\r\n        if (\"function\" !== typeof jQuery) {\r\n          importjquery();\r\n        } else {\r\n          /* 判断jquery版本号 */\r\n    /*       if (jQuery.fn.jquery[0] < 3) {\r\n            importjquery();\r\n          }\r\n        }\r\n        resolve();\r\n      });*/\r\n\r\n    document.write = t => {\r\n        console.warn(\r\n            \"document.write已被禁用，\" +\r\n              \"把document.write中的内容生成dom元素放入body之中\" +\r\n              \"要写入的内容为：\",\r\n            t\r\n          );\r\n\r\n    //   var jQuery;\r\n    //   /* 等到使用document.write时再加载jquery */\r\n    //   IMPORTCJSAMDUMD(\r\n    //     \"https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\",\r\n    //     \"jquery\"\r\n    //   ).then(module => {\r\n    //     jQuery = module.default;\r\n    //     // if (jQuery.fn.jquery[0] < 3) {\r\n    //     //   importjquery();\r\n    //     // }\r\n\r\n    //     console.warn(\r\n    //       \"document.write已被禁用，\" +\r\n    //         \"把document.write中的内容生成dom元素放入body之中\" +\r\n    //         \"要写入的内容为：\",\r\n    //       t\r\n    //     );\r\n    //     // var writeelement = document.createElement(\"div\");\r\n    //     // writeelement.innerHTML = t;\r\n    //     // document.getElementsByTagName(\"head\")[0].appendChild(writeelement);\r\n    //     var newelemnet = jQuery(t);\r\n    //     try {\r\n    //       newelemnet.attr(\"data-loadid\", loadid);\r\n    //     } catch (error) {\r\n    //       console.warn(error);\r\n    //       return;\r\n    //     }\r\n\r\n    //     //   newelemnet = jQuery(Array(...newelemnet).reverse());\r\n    //     jQuery(\"body\").append(newelemnet);\r\n    //     console.log(\"添加元素到body \");\r\n    //     /*  for (var i of newelemnet) {\r\n    //           console.log(i.outerHTML);\r\n    //         } */\r\n    //     console.log(Array(...newelemnet).map(i => i.outerHTML));\r\n    //     // console.log(\"把document.write中的内容生成dom元素放入head之中\");\r\n    //   });\r\n    };\r\n\r\n    //   function importjquery() {\r\n    //     if (\"function\" == typeof jQuery) {\r\n    //       console.log(\"当前的jquery版本号为\" + jQuery.fn.jquery);\r\n    //     } else {\r\n    //       console.log(\"当前的jquery不存在\");\r\n    //     }\r\n\r\n    //   importScripts(\"https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js\");\r\n    //     console.log(\"加载jquery版本号3.4.1\");\r\n    //   }\r\n\r\n    // Object.freeze(jQuery);\r\n    /* jQuery可能被覆盖,所以改名 */\r\n    //改名失败\r\n    // window.jQuery341 = jQuery;\r\n\r\n    /* 禁用 document.write*/\r\n\r\n    // document.charset = \"UTF-8\";/* 只读属性 */\r\n    window.removeEventListener(\"load\", windowloadhandler);\r\n\r\n    var htmldataboject = new Object();\r\n    Array(...document.querySelectorAll(\"a\")).forEach(e => {\r\n      if (e.href !== \"\") {\r\n        e.href = e.href;\r\n      }\r\n    });\r\n    Array(...document.querySelectorAll(\"script\")).forEach(e => {\r\n      if (e.src !== \"\") {\r\n        e.src = e.src;\r\n      }\r\n    });\r\n    /*  \r\n        Array(...document.querySelectorAll(\"link[rel='stylesheet']\")).forEach(e => {\r\n          if (e.href !== \"\") {\r\n            e.href = e.href;\r\n          }\r\n        }); */\r\n    document.firstElementChild.dataset.search = location.search;\r\n    document.firstElementChild.dataset.href = location.href;\r\n    document.firstElementChild.dataset.pathname = location.pathname;\r\n    console.log(\r\n      \"当前页面的document的href为\",\r\n      document.firstElementChild.dataset.href\r\n    );\r\n    console.log(\r\n      \"当前页面的document的pathname为\",\r\n      document.firstElementChild.dataset.pathname\r\n    );\r\n    console.log(\r\n      \"当前页面的document的search为\",\r\n      document.firstElementChild.dataset.search\r\n    );\r\n    // var lasthref;\r\n    //  document.firstElementChild.dataset.href = location.href;\r\n    替换a链接();\r\n    document.addEventListener(\"click\", 替换a链接);\r\n    window.addEventListener(\"hashchange\", 替换a链接);\r\n    document.addEventListener(\"scroll\", 替换a链接);\r\n    document.addEventListener(\"mouseover\", 替换a链接);\r\n\r\n    //   document.addEventListener(\"scroll\", 替换a链接);\r\n    var 替换a链接数组 = [];\r\n\r\n    function 替换a链接() {\r\n      requestAnimationFrame(() => {\r\n        替换a链接数组 = [];\r\n        //   if (\r\n        //     document.firstElementChild.dataset.search !== location.search ||\r\n        //     document.firstElementChild.dataset.href !== location.href ||\r\n        //     document.firstElementChild.dataset.pathname !== location.pathname\r\n        //   ) {\r\n        //     console.log(\r\n        //       \"当前页面的document的href为\",\r\n        //       document.firstElementChild.dataset.href\r\n        //     );\r\n        //     console.log(\r\n        //       \"当前页面的document的pathname为\",\r\n        //       document.firstElementChild.dataset.pathname\r\n        //     );\r\n        //     console.log(\r\n        //       \"当前页面的document的search为\",\r\n        //       document.firstElementChild.dataset.search\r\n        //     );\r\n        //   }\r\n        //   document.firstElementChild.dataset.search = location.search;\r\n        //   document.firstElementChild.dataset.href = location.href;\r\n        //   document.firstElementChild.dataset.pathname = location.pathname;\r\n\r\n        /* 把网页中的所有iframe中的a链接也进行替换 */\r\n        var alinkarr = Array.from(document.getElementsByTagName(\"a\"));\r\n        //   console.log(alinkarr);\r\n        alinkarr.forEach(替换所有a链接的arrayhandler);\r\n\r\n        var docuiframes = Array(...document.getElementsByTagName(\"iframe\"));\r\n        docuiframes.forEach(e => {\r\n          if (e.contentDocument) {\r\n            var iframealinkarr = Array(\r\n              ...e.contentDocument.getElementsByTagName(\"a\")\r\n            );\r\n            iframealinkarr.forEach(替换所有a链接的arrayhandler);\r\n          }\r\n        });\r\n        /*  e.onclick = () => {\r\n                        // lasthref=location.href\r\n                        console.log(e.href);\r\n                \r\n                        if (location.origin === e.origin) {\r\n                          if (e.pathname === location.pathname) {\r\n                            if (e.hash !== location.hash) {\r\n                              return true;\r\n                            } else {\r\n                              return false;\r\n                            }\r\n                          } else {\r\n                            history.pushState(undefined, undefined, e.href);\r\n                            console.log(\"执行,history.pushState,成功\");\r\n                            window.onpopstate();\r\n                            return false;\r\n                          }\r\n                \r\n                          //   return false;\r\n                        } else {\r\n                          return true;\r\n                        }\r\n                      }; */\r\n        // return true\r\n        if (替换a链接数组.length > 0) {\r\n          console.log(\"替换a链接\", 替换a链接数组);\r\n        }\r\n      });\r\n    }\r\n\r\n    function 替换所有a链接的arrayhandler(e) {\r\n      /* 尝试把http和https都替换,因为协议不同导致origin不同 */\r\n      // e.protocol = location.protocol;\r\n      /* 使用hostname代替origin判断 */\r\n      if (e.href !== \"\") {\r\n        e.href = e.href;\r\n      }\r\n      if (e.protocol === \"http:\" || e.protocol === \"https:\") {\r\n        /* 如果search不同也是不同的页面,比如说论坛 */\r\n        if (e.href != \"javascript:;\" && location.hostname === e.hostname) {\r\n          if (\r\n            e.pathname !== location.pathname ||\r\n            e.search !== location.search\r\n          ) {\r\n            e.dataset.href = e.href;\r\n\r\n            e.href = \"javascript:;\";\r\n\r\n            替换a链接数组.push({\r\n              name: \"替换a链接\",\r\n              text: e.outerHTML\r\n            });\r\n            /*  */\r\n            //   console.log(\"替换a链接\", e.outerHTML);\r\n            //\r\n\r\n            /* 不应该用onclick,防止与网页原本定义的onclick冲突 */\r\n            e.addEventListener(\"click\", () => {\r\n              /*   document.firstElementChild.dataset.href = location.href;\r\n                                      document.firstElementChild.dataset.pathname = location.pathname; */\r\n              var url = new URL(e.dataset.href);\r\n              /* 替换协议与当前网页相同的协议 */\r\n              url.protocol = location.protocol;\r\n              if (\r\n                (url.origin === location.origin &&\r\n                  url.pathname !== location.pathname) ||\r\n                url.search !== location.search\r\n              ) {\r\n                history.pushState(undefined, undefined, url);\r\n                window.dispatchEvent(new PopStateEvent(\"popstate\"));\r\n              }\r\n\r\n              //   动态加载网页内容不刷新(url);\r\n            });\r\n            /*    // e.onclick = () => {\r\n                        //   /*   document.firstElementChild.dataset.href = location.href;\r\n                        //           document.firstElementChild.dataset.pathname = location.pathname; */\r\n            //   var url = new URL(e.dataset.href);\r\n            //   /* 替换协议与当前网页相同的协议 */\r\n            //   url.protocol = location.protocol;\r\n            //   动态加载网页内容不刷新(url);\r\n            // }; */\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //   document.onclick();\r\n    function onpopstatehandler() {\r\n      console.log(\"事件onpopstate,执行,\");\r\n      //    document.firstElementChild.dataset.href = document.firstElementChild.dataset.href;\r\n      console.log(\r\n        \"当前的地址栏路径为\" + location.pathname,\r\n        \"当前的网页document路径为\" + document.firstElementChild.dataset.pathname\r\n      );\r\n      if (\r\n        document.firstElementChild.dataset.pathname !== location.pathname ||\r\n        document.firstElementChild.dataset.search !== location.search\r\n      ) {\r\n        console.log(\"动态加载网页内容不刷新开始执行\");\r\n        动态加载网页内容不刷新();\r\n      }\r\n\r\n      替换a链接();\r\n    }\r\n    window.addEventListener(\"popstate\", onpopstatehandler);\r\n    var script完成数量 = \"script完成数量\";\r\n    var script总数量 = \"script总数量\";\r\n    script加载完成[script完成数量] = script加载完成[script总数量] = 0;\r\n\r\n    function script加载完成(urlortext) {\r\n      //   script加载完成[script完成数量], script加载完成[script总数量];\r\n      if (script加载完成[script完成数量] === 0) scrollTo(0, 0);\r\n      //   console.log(\"滚动到顶部\")\r\n      替换a链接();\r\n      script加载完成[script完成数量]++;\r\n      console.log(\r\n        \"script完成数量\",\r\n        script加载完成[script完成数量],\r\n        \"script总数量\",\r\n        script加载完成[script总数量],\r\n        \"script加载完成\",\r\n        urlortext\r\n      );\r\n      //   console.log(\"script加载完成\", urlortext);\r\n      /* script完成数量 可能大于 script总数量 */\r\n      if (script加载完成[script完成数量] >= script加载完成[script总数量]) {\r\n        requestAnimationFrame(() => {\r\n          console.log(\"触发window的allscriptloadformsrc事件\");\r\n          window.dispatchEvent(new Event(\"allscriptloadformsrc\"));\r\n        });\r\n        // requestAnimationFrame(() => {\r\n        /* 应该等到最后所有的 文本内容的脚本执行完毕之后再触发window的load事件*/\r\n        function 所有文本内容加载的脚本完成() {\r\n          window.removeEventListener(\r\n            \"alltextscriptload\",\r\n            所有文本内容加载的脚本完成\r\n          );\r\n          requestAnimationFrame(() => {\r\n            console.log(\"触发window的load事件\");\r\n            window.dispatchEvent(new Event(\"load\"));\r\n          });\r\n        }\r\n        window.addEventListener(\r\n          \"alltextscriptload\",\r\n          所有文本内容加载的脚本完成\r\n        );\r\n        // });\r\n        /* 等到所有用src加载的script全部加载完成,再加载文本内容的script */\r\n\r\n        /* 创建新的事件 */\r\n        setTimeout(() => {\r\n          替换a链接();\r\n        }, 150);\r\n\r\n        // document.firstElementChild.dataset.href = location.href;\r\n        // document.firstElementChild.dataset.search = location.search;\r\n        // document.firstElementChild.dataset.pathname = location.pathname;\r\n        // console.log(\r\n        //   \"当前页面的document的href为\" + document.firstElementChild.dataset.href\r\n        // );\r\n        /*   document.firstElementChild.dataset.search = location.search;\r\n                document.firstElementChild.dataset.href = location.href;\r\n                document.firstElementChild.dataset.pathname = location.pathname;\r\n                console.log(\r\n                  \"当前页面的document的href为\",\r\n                  document.firstElementChild.dataset.href\r\n                );\r\n                console.log(\r\n                  \"当前页面的document的pathname为\",\r\n                  document.firstElementChild.dataset.pathname\r\n                );\r\n                console.log(\r\n                  \"当前页面的document的search为\",\r\n                  document.firstElementChild.dataset.search\r\n                ); */\r\n      }\r\n      /*  () => {\r\n                    setTimeout(() => {\r\n                      try {\r\n                        window.dispatchEvent(new Event(\"load\"));\r\n                      } catch (error) {\r\n                        console.log(error);\r\n                      }\r\n                    }, 300);\r\n                  };  */\r\n    }\r\n    /* 如果没有调用过 loadscript函数则不会触发allscriptloadformsrc事件,不会加载文本内容的script */\r\n    function loadscript(\r\n      fileurl,\r\n      loadguid = guid(),\r\n      callback = undefined,\r\n      errorcallback = undefined\r\n    ) {\r\n      var script = document.createElement(\"script\");\r\n      script.dataset.loadid = loadguid;\r\n      script.type = \"text/javascript\";\r\n      script.src = fileurl;\r\n      script.onload = () => {\r\n        callback(fileurl);\r\n      };\r\n      script.async = true;\r\n      script.onerror = () => {\r\n        errorcallback(fileurl);\r\n        // console.log(\"加载失败\" + fileurl);\r\n      };\r\n      document.getElementsByTagName(\"head\")[0].appendChild(script);\r\n\r\n      //   console.log(\"添加script到head\", script.outerHTML);\r\n      return script.outerHTML;\r\n    }\r\n\r\n    function loadscripttext(text, loadguid = guid()) {\r\n      var script = document.createElement(\"script\");\r\n      /* script.onerror = () => {\r\n              console.log(\"加载失败\" + fileurl);\r\n            }; */\r\n      //文本内容的脚本不会onerror\r\n      /*   script.onload = () => {\r\n                  callback(text);\r\n                }; */\r\n      /* 用文本创建的script不会执行onload事件 */\r\n      script.innerHTML = text;\r\n      script.type = \"text/javascript\";\r\n      script.dataset.loadid = loadguid;\r\n      script.async = true;\r\n      //   console.log(\"添加script到head\", script.outerHTML);\r\n      document.getElementsByTagName(\"head\")[0].appendChild(script);\r\n      return script.outerHTML;\r\n    }\r\n\r\n    function loadstylesheet(\r\n      fileurl,\r\n      loadguid = guid(),\r\n      callback = undefined,\r\n      errorcallback = undefined\r\n    ) {\r\n      var script = document.createElement(\"link\");\r\n      script.dataset.loadid = loadguid;\r\n      script.rel = \"stylesheet\";\r\n      script.href = fileurl;\r\n      script.onload = () => {\r\n        callback(fileurl);\r\n      };\r\n      script.type = \"text/css\";\r\n      script.onerror = () => {\r\n        errorcallback(fileurl);\r\n        // console.log(\"加载失败\" + fileurl);\r\n      };\r\n      document.getElementsByTagName(\"head\")[0].appendChild(script);\r\n\r\n      //   console.log(script);\r\n      return script.outerHTML;\r\n    }\r\n\r\n    function guid() {\r\n      return \"xxxxxxxx-xxxx-yxxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(\r\n        t\r\n      ) {\r\n        var e = (16 * Math.random()) | 0;\r\n        return (\"x\" == t ? e : (3 & e) | 8).toString(16);\r\n      });\r\n    }\r\n    /*  // function fetchhandler(arraybuffer) {\r\n        //   console.log(arraybuffer);\r\n        //   var sr, myhtmldata;\r\n        //   var loadid = guid();\r\n        //   //   document.charset = \"UTF-8\";\r\n        //   /* 把源代码的编码转成unicode */\r\n    //   //   var sr = text;\r\n    //   //   console.log(sr);\r\n    //   sr = new TextDecoder().decode(arraybuffer);\r\n    //   myhtmldata = new DOMParser().parseFromString(sr, \"text/html\");\r\n    //   //   var myhtmldata = new DOMParser().parseFromString(sr, \"text/html\");\r\n    //   /*myhtmldata.charset得出的结果不正确\r\n    //   使用response.headers.get(\"Content-Type\")\r\n    //   得出\"text/html; charset=gbk\" */\r\n    //   //   console.log(myhtmldata.charset);\r\n    //   var myhtmlcharset;\r\n    //   if (myhtmlcharset != \"UTF-8\") {\r\n    //     console.log(\"编码不是utf-8,转码成\" + myhtmldata.charset);\r\n    //     sr = new TextDecoder(myhtmldata.charset).decode(arraybuffer);\r\n    //     myhtmldata = new DOMParser().parseFromString(sr, \"text/html\");\r\n    //     myhtmldata.charset = \"UTF-8\";\r\n    //   }\r\n    //   htmldataboject[decodeURI(new URL(myhtmldata.URL).pathname)] = {\r\n    //     url: myhtmldata.URL,\r\n    //     text: sr\r\n    //   };\r\n    //   console.log(\"加载过的网页的源代码合集\", htmldataboject);\r\n    //   console.log(myhtmldata);\r\n    //   document.title = myhtmldata.title;\r\n    //   // window.myhtmldata = myhtmldata;\r\n    //   document.getElementsByTagName(\r\n    //     \"body\"\r\n    //   )[0].innerHTML = myhtmldata.getElementsByTagName(\"body\")[0].innerHTML;\r\n    //   /*  Array.from(document.querySelectorAll(\"link\")).forEach(e => {\r\n    //     e.parentNode.removeChild(e);\r\n    //   });\r\n    //   Array.from(document.querySelectorAll(\"style\")).forEach(e => {\r\n    //     e.parentNode.removeChild(e);\r\n    //   });\r\n    //   Array.from(document.querySelectorAll(\"meta\")).forEach(e => {\r\n    //     e.parentNode.removeChild(e);\r\n    //   });\r\n    //   Array.from(document.querySelectorAll(\"script\")).forEach(e => {\r\n    //     e.parentNode.removeChild(e);\r\n    //   }); */\r\n    //   Array.from(myhtmldata.querySelectorAll(\"link[rel='stylesheet']\")).forEach(\r\n    //     e => {\r\n    //       e.dataset.loadid = loadid;\r\n    //       e.onerror = () => {\r\n    //         console.log(\"加载失败\" + e.href);\r\n    //       };\r\n    //       e.type = \"text/css\";\r\n    //       e.href = e.href;\r\n    //       console.log(\"添加css元素到head\", e.outerHTML);\r\n    //       document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //     }\r\n    //   );\r\n\r\n    //   Array.from(myhtmldata.querySelectorAll(\"link\")).forEach(e => {\r\n    //     e.dataset.loadid = loadid;\r\n\r\n    //     e.href = e.href;\r\n    //     console.log(\"添加元素到head\", e.outerHTML);\r\n    //     document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //   });\r\n\r\n    //   Array.from(myhtmldata.querySelectorAll(\"style\")).forEach(e => {\r\n    //     e.type = \"text/css\";\r\n    //     e.dataset.loadid = loadid;\r\n    //     console.log(\"添加css元素到head\", e.outerHTML);\r\n    //     document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //   });\r\n\r\n    //   Array.from(myhtmldata.querySelectorAll(\"meta\")).forEach(e => {\r\n    //     e.dataset.loadid = loadid;\r\n    //     console.log(\"添加元素到head\", e.outerHTML);\r\n    //     document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //   });\r\n\r\n    //   /*    document.getElementsByTagName(\r\n    //     \"body\"\r\n    //   )[0].innerHTML = myhtmldata.getElementsByTagName(\"body\")[0].innerHTML; */\r\n    //   script完成数量 = 0;\r\n    //   script总数量 = Array.from(myhtmldata.querySelectorAll(\"script\")).length;\r\n    //   Array.from(myhtmldata.querySelectorAll(\"script\")).forEach(e => {\r\n    //     e.type = e.type.toLowerCase();\r\n    //     if (e.type == \"text/javascript\" || \"\" == e.type) {\r\n    //       e.type = \"text/javascript\";\r\n    //       if (e.src != \"\") {\r\n    //         e.src = e.src;\r\n    //         /* 但是如果有些脚本不重复加载,可能网页出错 */\r\n    //         /* 不要重复加载javascipt文件,否则可能出问题 */\r\n    //         loadscript(e.src, loadid, script加载完成);\r\n    //       } else {\r\n    //         loadscripttext(e.innerHTML, loadid);\r\n    //         script完成数量++;\r\n    //       }\r\n    //     } else {\r\n    //       /* 不是javascript文件 */\r\n    //       if (e.src != \"\") {\r\n    //         e.src = e.src;\r\n    //       }\r\n    //       console.log(\"添加元素到head\", e.outerHTML);\r\n    //       e.dataset.loadid = loadid;\r\n    //       script完成数量++;\r\n    //       document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //     }\r\n\r\n    //     //////////////////////////////\r\n    //     //   console.log(\"e.type\",e.type)\r\n    //     // /* if (e.src) {\r\n    //     //   e.src = e.src;\r\n    //     //   if (e.type == \"text/javascript\" || \"\" == e.type) {\r\n    //     //     loadscript(e.src, loadid, script加载完成);\r\n    //     //   } else {\r\n    //     //     console.log(\"添加元素到head\", e);\r\n    //     //     //   script加载完成();\r\n    //     //     script完成数量++;\r\n    //     //     document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //     //   }\r\n    //     // } else {\r\n    //     //   // console.log(\"script-innertext\", e.innerText.replace(/\\n/g,\";\"));\r\n    //     //   /* if (\"\"==e.type) {\r\n\r\n    //     //     e.type = \"text/javascript\";\r\n    //     //   } */\r\n    //     //   e.onerror = () => {\r\n    //     //     console.log(\"加载失败\" + e.src);\r\n    //     //   };\r\n    //     //   e.dataset.loadid = loadid;\r\n    //     //   // e.async = true;\r\n    //     //   if (e.type == \"text/javascript\" || \"\" == e.type) {\r\n    //     //     e.type = \"text/javascript\";\r\n    //     //     loadscripttext(e.innerHTML, loadid);\r\n    //     //     //   script加载完成();\r\n    //     //     script完成数量++;\r\n    //     //     /*  var script = document.createElement(\"script\");\r\n    //     //         script.onload = script加载完成;\r\n    //     //         script.innerHTML = e.innerHTML;\r\n    //     //         script.type = e.type;\r\n    //     //         script.dataset.loadid = e.dataset.loadid;\r\n    //     //         console.log(script);\r\n    //     //         document.getElementsByTagName(\"head\")[0].appendChild(script); */\r\n    //     //   } else {\r\n    //     //     console.log(\"添加元素到head\", e);\r\n    //     //     //   script加载完成();\r\n    //     //     script完成数量++;\r\n    //     //     document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //     //   }\r\n    //     // } */\r\n    //   });\r\n    //   /*  Array.from(\r\n    //     document.getElementsByTagName(\"body\")[0].querySelectorAll(\"script\")\r\n    //   ).forEach(e => {\r\n    //     e.parentNode.removeChild(e);\r\n    //   }); */\r\n\r\n    //   Array(\r\n    //     ...document.querySelectorAll(\"link\"),\r\n    //     ...document.querySelectorAll(\"style\"),\r\n    //     ...document.querySelectorAll(\"meta\"),\r\n    //     ...document.querySelectorAll(\"script\")\r\n    //   ).forEach(e => {\r\n    //     if (loadid != e.dataset.loadid) {\r\n    //       e.parentNode.removeChild(e);\r\n    //       console.log(\"删除旧元素\", e.outerHTML);\r\n    //     }\r\n    //   });\r\n    //   /* Array.from(document.querySelectorAll(\"style\")).forEach(e => {\r\n    //     if (!e.dataset.loadid) {\r\n    //       e.parentNode.removeChild(e);\r\n    //       console.log(\"删除旧元素\", e);\r\n    //     }\r\n    //   });\r\n    //   Array.from(document.querySelectorAll(\"meta\")).forEach(e => {\r\n    //     if (!e.dataset.loadid) {\r\n    //       e.parentNode.removeChild(e);\r\n    //       console.log(\"删除旧元素\", e);\r\n    //     }\r\n    //   });\r\n    //   Array.from(document.querySelectorAll(\"script\")).forEach(e => {\r\n    //     if (!e.dataset.loadid) {\r\n    //       e.parentNode.removeChild(e);\r\n    //       console.log(\"删除旧元素\", e);\r\n    //     }\r\n    //   });*/\r\n\r\n    //   // document.charset=\"UTF-8\"\r\n    //   /*  Array.from(myhtmldata.querySelectorAll(\"script\")).forEach(e => {\r\n    //         if (e.src) {\r\n    //           e.src = e.src;\r\n    //           loadscript(e.src);\r\n    //         } else {\r\n    //           if (!e.type) {\r\n    //             e.type = \"text/javascript\";\r\n    //           }\r\n    //           e.onerror = () => {\r\n    //             console.log(\"加载失败\" + e.src);\r\n    //           };\r\n    //           e.dataset.loadid = loadid;\r\n    //           e.async = true;\r\n    //           //   console.log(e.src)\r\n    //           document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n    //         }\r\n    //       }); */\r\n    //   /* setTimeout(() => {\r\n    //         try {\r\n    //           window.dispatchEvent(new Event(\"load\"));\r\n    //         } catch (error) {\r\n    //           console.log(error);\r\n    //         }\r\n    //       }, 300); */\r\n    // } */\r\n    var 完成linkstylesheet = \"完成linkstylesheet\";\r\n    var 数量linkstylesheet = \"数量linkstylesheet\";\r\n    单个stylesheet加载完成[完成linkstylesheet] = 单个stylesheet加载完成[\r\n      数量linkstylesheet\r\n    ] = 0;\r\n\r\n    function 单个stylesheet加载完成(fileurl) {\r\n      替换a链接();\r\n      单个stylesheet加载完成[完成linkstylesheet]++;\r\n      console.log(\r\n        \"完成linkstylesheet\",\r\n        单个stylesheet加载完成[完成linkstylesheet],\r\n        \"数量linkstylesheet\",\r\n        单个stylesheet加载完成[数量linkstylesheet],\r\n        \"stylesheet加载完成\",\r\n        fileurl\r\n      );\r\n\r\n      if (\r\n        单个stylesheet加载完成[完成linkstylesheet] >=\r\n        单个stylesheet加载完成[数量linkstylesheet]\r\n      ) {\r\n        requestAnimationFrame(() => {\r\n          console.log(\"触发window的allstylesheetload事件\");\r\n          window.dispatchEvent(new Event(\"allstylesheetload\"));\r\n        });\r\n      }\r\n      setTimeout(() => {\r\n        替换a链接();\r\n      }, 150);\r\n    }\r\n\r\n    function 失败StyleSheet(fileurl) {\r\n      /* 如果加载失败也要触发事件 */\r\n      console.warn(\"加载失败\" + fileurl);\r\n      单个stylesheet加载完成[完成linkstylesheet]++;\r\n      if (\r\n        单个stylesheet加载完成[完成linkstylesheet] >=\r\n        单个stylesheet加载完成[数量linkstylesheet]\r\n      ) {\r\n        requestAnimationFrame(() => {\r\n          console.log(\"触发window的allstylesheetload事件\");\r\n          window.dispatchEvent(new Event(\"allstylesheetload\"));\r\n        });\r\n      }\r\n    }\r\n\r\n    function 失败scriptsrc(fileurl) {\r\n      /* 如果加载失败也要触发事件 */\r\n      console.warn(\"加载失败\" + fileurl);\r\n      script加载完成[script完成数量]++;\r\n      if (script加载完成[script完成数量] >= script加载完成[script总数量]) {\r\n        requestAnimationFrame(() => {\r\n          window.dispatchEvent(new Event(\"allscriptloadformsrc\"));\r\n          console.log(\"触发window的allscriptloadformsrc事件\");\r\n        });\r\n        // requestAnimationFrame(() => {\r\n        //   console.log(\"触发window的load事件\");\r\n        //   window.dispatchEvent(new Event(\"load\"));\r\n        // });\r\n      }\r\n    }\r\n\r\n    async function 动态加载网页内容不刷新(url = location.href) {\r\n      单个stylesheet加载完成[数量linkstylesheet] = 0;\r\n      单个stylesheet加载完成[完成linkstylesheet] = 0;\r\n      script加载完成[script总数量] = 0;\r\n      script加载完成[script完成数量] = 0;\r\n      //   document.charset = \"UTF-8\";\r\n      /*  if (typeof url === \"undefined\") {\r\n              url = location.href;\r\n            } else  */\r\n      url = new URL(url);\r\n      url.protocal = location.protocol;\r\n      /* 如果url和当前页面的search不同则执行 */\r\n      if (\r\n        (location.hostname === url.hostname &&\r\n          url.pathname !== location.pathname) ||\r\n        url.pathname !== document.firstElementChild.dataset.pathname ||\r\n        url.search !== document.firstElementChild.dataset.search\r\n      ) {\r\n        console.log(\"动态加载网页内容不刷新,执行\" + url);\r\n        // var urlorighin = new URL(url).origin;\r\n        //    document.firstElementChild.dataset.href = location.href;\r\n        if (\r\n          url.pathname == document.firstElementChild.dataset.pathname &&\r\n          url.search == document.firstElementChild.dataset.search\r\n        ) {\r\n          return;\r\n          //   history.pushState(undefined, undefined, url);\r\n          /* 等到加载成功再pushstate */\r\n        }\r\n\r\n        // var nowurl = location.href;\r\n        console.log(\r\n          \"替换当前的网址\" + document.firstElementChild.dataset.href,\r\n          \"改成\",\r\n          url.href\r\n        );\r\n        /* 竟然有的网页甚至还要给html标签加style! */\r\n        // document.firstElementChild.style = \"\";\r\n        /* 添加顺滑的滚动效果在scrollto的时候用到 */\r\n        document.firstElementChild.style=\"scroll-behavior: smooth;\"\r\n        // $(\"html\").css(\"scroll-behavior\", \"smooth\");\r\n        document.firstElementChild.className = \"\";\r\n        document.getElementsByTagName(\"body\")[0].style = \"\";\r\n        document.getElementsByTagName(\"body\")[0].className = \"\";\r\n        /* 返回文本和二进制数组,用来转换编码 */\r\n        console.log(\"开始发起fetch请求\", url);\r\n        var dataresponse;\r\n        try {\r\n          var myhtmlcharset;\r\n          try {\r\n            dataresponse = await fetch(url);\r\n          } catch (error) {\r\n            console.warn(error);\r\n            history.pushState(\r\n              undefined,\r\n              undefined,\r\n              document.firstElementChild.dataset.href\r\n            );\r\n            window.open(url, \"_blank\");\r\n            console.log(\"此链接加载失败，打开新页面\");\r\n            /* 有些网站的不同页面是用不同的http协议 */\r\n            if (url.protocal === \"https:\") {\r\n              url.protocal = \"http:\";\r\n            } else {\r\n              url.protocal = \"https:\";\r\n            }\r\n            try {\r\n              dataresponse = await fetch(url);\r\n            } catch (error) {\r\n              console.warn(error);\r\n              history.pushState(\r\n                undefined,\r\n                undefined,\r\n                document.firstElementChild.dataset.href\r\n              );\r\n              return;\r\n              //   history.back();\r\n            }\r\n          }\r\n          /* 如果链接的protocol与当前的网页的protocol不同,则fetch加载失败 */\r\n          if (typeof dataresponse != \"undefined\") {\r\n            console.log(\"response\", dataresponse);\r\n            if (dataresponse.ok == false) {\r\n              console.log(\"此链接加载失败，\", dataresponse.status);\r\n              history.pushState(\r\n                undefined,\r\n                undefined,\r\n                document.firstElementChild.dataset.href\r\n              );\r\n              return;\r\n            }\r\n            try {\r\n              var arraybuffer = await dataresponse.arrayBuffer();\r\n              console.log(\"html二进制数组\", arraybuffer);\r\n              /* 等到加载成功再pushstate */\r\n              /* 如果网页的类型正确再pushstate */\r\n            } catch (error) {\r\n              console.warn(error);\r\n              console.log(\"此链接加载失败，打开新页面\");\r\n              //     history.pushState(undefined, undefined, url);\r\n\r\n              //    location.reload();\r\n              /* 如果直接设置location.href会刷新页面 */\r\n              history.pushState(\r\n                undefined,\r\n                undefined,\r\n                \"document.firstElementChild.dataset.href\"\r\n              );\r\n              //   location.search = document.firstElementChild.dataset.search;\r\n              //   location.href = document.firstElementChild.dataset.href;\r\n              //   location.pathname = document.firstElementChild.dataset.pathname;\r\n              window.open(url, \"_blank\");\r\n              return;\r\n              // history.back();\r\n              // history.pushState(\r\n              //   undefined,\r\n              //   undefined,\r\n              //   document.firstElementChild.dataset.href\r\n              // );\r\n            }\r\n          }\r\n          var datacontenttype;\r\n          try {\r\n            datacontenttype = dataresponse.headers\r\n              .get(\"Content-Type\")\r\n              .toLowerCase();\r\n            console.log(\"Content-Type\", datacontenttype);\r\n\r\n            if (!datacontenttype.includes(\"text/html\")) {\r\n              console.log(\"此链接不是网页，打开新页面\");\r\n              //     history.pushState(undefined, undefined, url);\r\n              window.open(url, \"_blank\");\r\n              history.pushState(\r\n                undefined,\r\n                undefined,\r\n                document.firstElementChild.dataset.href\r\n              );\r\n              /*  location.search = document.firstElementChild.dataset.search;\r\n            location.href = document.firstElementChild.dataset.href;\r\n            location.pathname = document.firstElementChild.dataset.pathname; */\r\n              return;\r\n              //    location.reload();\r\n            }\r\n          } catch (error) {\r\n            console.warn(error);\r\n            console.log(\"此链接加载失败，打开新页面\");\r\n            history.pushState(\r\n              undefined,\r\n              undefined,\r\n              \"document.firstElementChild.dataset.href\"\r\n            );\r\n            window.open(url, \"_blank\");\r\n            return;\r\n          }\r\n\r\n          /* fetch加载成功,而且网页类型正确 */\r\n          //   history.pushState(undefined, undefined, url);\r\n\r\n          if (\r\n            document.firstElementChild.dataset.search !== location.search ||\r\n            document.firstElementChild.dataset.href !== location.href ||\r\n            document.firstElementChild.dataset.pathname !== location.pathname\r\n          ) {\r\n            document.firstElementChild.dataset.search = location.search;\r\n            document.firstElementChild.dataset.href = location.href;\r\n            document.firstElementChild.dataset.pathname = location.pathname;\r\n            console.log(\r\n              \"当前页面的document的href为\",\r\n              document.firstElementChild.dataset.href\r\n            );\r\n            console.log(\r\n              \"当前页面的document的pathname为\",\r\n              document.firstElementChild.dataset.pathname\r\n            );\r\n            console.log(\r\n              \"当前页面的document的search为\",\r\n              document.firstElementChild.dataset.search\r\n            );\r\n          }\r\n\r\n          if (datacontenttype.includes(\"charset\")) {\r\n            myhtmlcharset = datacontenttype.slice(\r\n              datacontenttype.indexOf(\"charset\") + \"charset\".length + 1\r\n            );\r\n            if (\"utf-8\" === myhtmlcharset) {\r\n              console.log(\"文档的编码是utf-8\");\r\n            } else {\r\n              console.log(\"编码不是utf-8,当前的编码是\" + myhtmlcharset);\r\n            }\r\n          } else {\r\n            myhtmlcharset = \"utf-8\";\r\n            try {\r\n              /* 有的网站不在response中返回charset,又不是utf-8,在document中的meta的charset属性获取 \r\n            <meta charset=\"gbk\" >*/\r\n\r\n              var charsetelement = Array(\r\n                ...new DOMParser()\r\n                  .parseFromString(\r\n                    new TextDecoder().decode(arraybuffer),\r\n                    \"text/html\"\r\n                  )\r\n                  .querySelectorAll(\"meta[charset]\")\r\n              )[0];\r\n              if (typeof charsetelement != \"undefined\") {\r\n                myhtmlcharset = charsetelement\r\n                  .getAttribute(\"charset\")\r\n                  .toLowerCase();\r\n              }\r\n            } catch (error) {\r\n              console.warn(error);\r\n            }\r\n\r\n            /*\r\n                        有的网页没有document中的meta的charset属性\r\n                        \r\n                        只有meta http-equiv=\"Content-Type\"\r\n                        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\" >\r\n                        */\r\n            try {\r\n              var charsetelement = Array(\r\n                ...new DOMParser()\r\n                  .parseFromString(\r\n                    new TextDecoder().decode(arraybuffer),\r\n                    \"text/html\"\r\n                  )\r\n                  .querySelectorAll(`meta[http-equiv=\"Content-Type\"]`)\r\n              )[0];\r\n              if (typeof charsetelement != \"undefined\") {\r\n                var dataContentType = charsetelement\r\n                  .getAttribute(\"content\")\r\n                  .toLowerCase();\r\n                myhtmlcharset = dataContentType.slice(\r\n                  dataContentType.indexOf(\"charset\") + \"charset\".length + 1\r\n                );\r\n              }\r\n            } catch (error) {\r\n              console.warn(error);\r\n            }\r\n\r\n            // console.log(\"文档的编码是utf-8\");\r\n            if (\"utf-8\" === myhtmlcharset) {\r\n              console.log(\"文档的编码是utf-8\");\r\n            } else {\r\n              console.log(\"编码不是utf-8,当前的编码是\" + myhtmlcharset);\r\n            }\r\n          }\r\n\r\n          loadid = guid();\r\n          var sr = new TextDecoder(myhtmlcharset).decode(arraybuffer);\r\n          var myhtmldata = new DOMParser().parseFromString(sr, \"text/html\");\r\n          var mynewhtmldataurl = new URL(myhtmldata.URL);\r\n          htmldataboject[\r\n            decodeURI(mynewhtmldataurl.pathname + mynewhtmldataurl.search)\r\n          ] = {\r\n            url: myhtmldata.URL,\r\n            text: sr,\r\n            title: myhtmldata.title,\r\n            charset: myhtmlcharset\r\n          };\r\n          console.log(\"加载过的网页的源代码合集\", htmldataboject);\r\n\r\n          console.log(myhtmldata);\r\n          //   requestAnimationFrame(() => {\r\n          document.title = myhtmldata.title;\r\n          document.getElementsByTagName(\r\n            \"body\"\r\n          )[0].innerHTML = myhtmldata.getElementsByTagName(\"body\")[0].innerHTML;\r\n\r\n          document.getElementsByTagName(\r\n            \"body\"\r\n          )[0].style = myhtmldata.getElementsByTagName(\"body\")[0].style;\r\n          //   });\r\n          document.getElementsByTagName(\r\n            \"body\"\r\n          )[0].className = myhtmldata.getElementsByTagName(\"body\")[0].className;\r\n\r\n          /* 把源代码中的body的style也加载到document的body中 */\r\n\r\n          单个stylesheet加载完成[完成linkstylesheet] = 0;\r\n          单个stylesheet加载完成[数量linkstylesheet] = Array.from(\r\n            myhtmldata.querySelectorAll(\"link[rel='stylesheet']\")\r\n          ).length;\r\n\r\n          /* 有href的link 的stylesheet 也要设置onload之后,全部加载完成之后,再删除旧元素*/\r\n          window.addEventListener(\r\n            \"allscriptloadformsrc\",\r\n            onallscriptloadformsrchandler\r\n          );\r\n          window.addEventListener(\"allstylesheetload\", allstyleloadhandler);\r\n          /* 提前添加事件监听器,防止添加晚了就接搜不到 */\r\n          //   requestAnimationFrame(() => {\r\n          var 添加stylesheet元素到head数组 = [];\r\n          Array.from(\r\n            myhtmldata.querySelectorAll(\"link[rel='stylesheet']\")\r\n          ).forEach(e => {\r\n            e.dataset.loadid = loadid;\r\n            /* e.onerror = () => {\r\n                            console.log(\"加载失败\" + e.href);\r\n                          }; */\r\n            e.type = \"text/css\";\r\n            /* 居然有的stylesheet没有href的值 */\r\n            if (e.href != \"\") {\r\n              e.href = e.href;\r\n              添加stylesheet元素到head数组.push({\r\n                type: e.type,\r\n                name: \"添加css元素\",\r\n                text: loadstylesheet(\r\n                  e.href,\r\n                  loadid,\r\n                  单个stylesheet加载完成,\r\n                  失败StyleSheet\r\n                )\r\n              });\r\n            } else {\r\n              单个stylesheet加载完成[数量linkstylesheet]--;\r\n            }\r\n\r\n            //   console.log(\"添加css元素到head\", e.outerHTML);\r\n            //   document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n          });\r\n          console.log(\r\n            \"添加stylesheet元素到head数组\",\r\n            添加stylesheet元素到head数组\r\n          );\r\n          if (添加stylesheet元素到head数组.length === 0)\r\n            单个stylesheet加载完成();\r\n          //   });\r\n\r\n          //   requestAnimationFrame(() => {\r\n          var 添加元素到head数组 = [];\r\n          Array.from(myhtmldata.querySelectorAll(\"link\")).forEach(e => {\r\n            if (e.getAttribute(\"rel\") !== \"stylesheet\") {\r\n              e.dataset.loadid = loadid;\r\n              if (e.href !== \"\") {\r\n                e.href = e.href;\r\n              }\r\n              添加元素到head数组.push({\r\n                name: \"添加link元素\",\r\n                text: e.outerHTML\r\n              });\r\n              //   console.log(\"添加link元素到head\", e.outerHTML);\r\n              document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n            }\r\n          });\r\n\r\n          Array.from(myhtmldata.querySelectorAll(\"style\")).forEach(e => {\r\n            e.type = \"text/css\";\r\n            e.dataset.loadid = loadid;\r\n            添加元素到head数组.push({\r\n              name: \"添加css元素\",\r\n              text: e.outerHTML\r\n            });\r\n            //   console.log(\"添加css元素到head\", e.outerHTML);\r\n            document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n          });\r\n\r\n          Array.from(myhtmldata.querySelectorAll(\"meta\")).forEach(e => {\r\n            e.dataset.loadid = loadid;\r\n            //   console.log(\"添加meta元素到head\", e.outerHTML);\r\n            添加元素到head数组.push({\r\n              name: \"添加meta元素\",\r\n              text: e.outerHTML\r\n            });\r\n            document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n          });\r\n\r\n          console.log(\"添加其他元素到head\", 添加元素到head数组);\r\n\r\n          script加载完成[script完成数量] = 0;\r\n          script加载完成[script总数量] = Array.from(\r\n            myhtmldata.querySelectorAll(\"script\")\r\n          ).length;\r\n          var 添加文本script元素数组 = [];\r\n          var script文本内容数组 = [];\r\n          //   requestAnimationFrame(() => {\r\n          var 添加script元素数组 = [];\r\n          script文本内容数组 = [];\r\n          Array.from(myhtmldata.querySelectorAll(\"script\")).forEach(e => {\r\n            e.type = e.type.toLowerCase();\r\n            if (e.type == \"text/javascript\" || \"\" == e.type) {\r\n              e.type = \"text/javascript\";\r\n              if (e.src != \"\") {\r\n                e.src = e.src;\r\n                /* 使用src加载的javascript */\r\n                /* 但是如果有些脚本不重复加载,可能网页出错 */\r\n                /* 不要重复加载javascipt文件,否则可能出问题 */\r\n                添加script元素数组.push({\r\n                  type: e.type,\r\n                  name: \"添加script元素\",\r\n                  text: loadscript(e.src, loadid, script加载完成, 失败scriptsrc)\r\n                });\r\n                //   loadscript(e.src, loadid, script加载完成);\r\n                /* 函数返回outerhtml */\r\n              } else {\r\n                // /* /* 使用文本内容加载的javascript */\r\n                /* 把这些文本放到一个数组当中去,然后再一起加载,只添加一个eventlistener */\r\n                /*  setTimeout(() => {\r\n                                    loadscripttext(e.innerHTML, loadid);\r\n                                  }, 50); */\r\n                /* 等到使用了src加载的javascipt全部加载完成之后,在执行文本内容加载的javascript */\r\n                /* 不是在这里加id */\r\n                //   e.dataset.loadid = loadid;\r\n                /* 要先加上id才行,不然,如果没有使用src加载的脚本时 ,或者stylesheet先加载完成时,脚本还没有执行就被删除了*/\r\n                script文本内容数组.push(e.innerHTML);\r\n\r\n                // /*\r\n\r\n                //                   window.addEventListener(\"allscriptloadformsrc\", onallscriptloadformsrc);\r\n                //                   function onallscriptloadformsrc() {\r\n                //                     window.removeEventListener(\r\n                //                       \"allscriptloadformsrc\",\r\n                //                       onallscriptloadformsrc\r\n                //                     );\r\n                //                     var 添加script元素数组 = [];\r\n                //                     /* 函数返回outerhtml */\r\n                //                     添加script元素数组.push({\r\n                //                       name: \"添加script元素\",\r\n                //                       text: loadscripttext(e.innerHTML, loadid)\r\n                //                     });\r\n                //                     // loadscripttext(e.innerHTML, loadid);\r\n                //                     /*  script加载完成 */\r\n                //                     console.log(\r\n                //                       \"添加文本内容加载的script元素\",\r\n                //                       添加script元素数组\r\n                //                     );\r\n                //                   }\r\n                //                   script加载完成[script总数量]--; */\r\n\r\n                /* script加载完成[script完成数量]++; */\r\n              }\r\n            } else {\r\n              /* 不是javascript文件的script */\r\n              if (e.src != \"\") {\r\n                e.src = e.src;\r\n              }\r\n              e.dataset.loadid = loadid;\r\n              // console.log(\"添加元素到head\", e.outerHTML);\r\n              添加script元素数组.push({\r\n                type: e.type,\r\n                name: \"添加script元素\",\r\n                text: e.outerHTML\r\n              });\r\n              // script加载完成[script完成数量]++;\r\n              document.getElementsByTagName(\"head\")[0].appendChild(e);\r\n              script加载完成[script总数量]--;\r\n            }\r\n            /*  console.log(\r\n                            \"script总数量\",\r\n                            script加载完成[script总数量],\r\n                            \"script完成数量\",\r\n                            script加载完成[script完成数量]\r\n                          ); */\r\n            /* 居然有的网站都没有通过src加载的script元素!,全都用文本的script而且还全都是document.write! */\r\n            //   if (\r\n            //     script加载完成[script总数量] === script加载完成[script完成数量]\r\n            //   ) {\r\n            //     script加载完成();\r\n            //   }\r\n          });\r\n          /* 当没有通过src加载的script时,script总数量,等于, script完成数量, */\r\n          console.log(\"添加通过src加载的script元素\", 添加script元素数组);\r\n\r\n          script文本内容数组.forEach(() => {\r\n            script加载完成[script总数量]--;\r\n          });\r\n          if (添加script元素数组.length === 0) script加载完成();\r\n          // var 添加文本script元素数组 = [];\r\n          function onallscriptloadformsrchandler() {\r\n            window.removeEventListener(\r\n              \"allscriptloadformsrc\",\r\n              onallscriptloadformsrchandler\r\n            );\r\n            script文本内容数组.forEach(text => {\r\n              // var 添加script元素数组 = [];\r\n              /* 函数返回outerhtml */\r\n              添加文本script元素数组.push({\r\n                type: \"text/javascript\",\r\n                name: \"添加script元素\",\r\n                text: loadscripttext(text, loadid)\r\n              });\r\n              // loadscripttext(e.innerHTML, loadid);\r\n              /*  script加载完成 */\r\n\r\n              // script加载完成[script总数量]--;\r\n            });\r\n            console.log(\"添加文本内容加载的script元素\", 添加文本script元素数组);\r\n            window.dispatchEvent(new Event(\"alltextscriptload\"));\r\n          }\r\n          /* 如果添加allscriptloadformsrc的监听事件之前,就已经触发了allscriptloadformsrc事件则,接收不到 ,\r\n应该早一点添加事件监听器*/\r\n          //   window.addEventListener(\"allscriptloadformsrc\", onallscriptloadformsrchandler);\r\n\r\n          //   setTimeout(() => {\r\n          //   requestAnimationFrame(() => {\r\n          function allstyleloadhandler() {\r\n            window.removeEventListener(\r\n              \"allstylesheetload\",\r\n              allstyleloadhandler\r\n            );\r\n            var 删除旧元素数组 = [];\r\n\r\n            Array(\r\n              ...document.querySelectorAll(\"link\"),\r\n              ...document.querySelectorAll(\"style\"),\r\n              ...document.querySelectorAll(\"meta\"),\r\n              ...document.querySelectorAll(\"script\")\r\n            ).forEach(e => {\r\n              if (loadid != e.dataset.loadid) {\r\n                e.parentNode.removeChild(e);\r\n                删除旧元素数组.push({\r\n                  name: \"删除元素\",\r\n                  text: e.outerHTML\r\n                });\r\n                // console.log(\"删除旧元素\", e.outerHTML);\r\n              }\r\n            });\r\n\r\n            console.log(\"删除旧元素\", 删除旧元素数组);\r\n          } /* 提前添加事件监听器,防止添加晚了就接搜不到 */\r\n          /*  */\r\n          //   window.addEventListener(\"allstylesheetload\", allstyleloadhandler);\r\n          //   });\r\n          //   }, 100);\r\n\r\n          //使用async函数\r\n\r\n          /*   fetch(url)\r\n                      .then(r => {\r\n                        console.log(r);\r\n                        //   console.log(r,r.text(),r.arrayBuffer());\r\n                        return r.arrayBuffer();\r\n                      })\r\n                      .then(fetchhandler); */\r\n        } catch (error) {\r\n          console.warn(error);\r\n          /* if (url.protocal === \"https:\") {\r\n            url.protocal = \"http:\";\r\n          } else {\r\n            url.protocal = \"https:\";\r\n          }\r\n//不需要了,因为已经在a链接的onclick函数中设置过了\r\n          fetch(url)\r\n            .then(r => {\r\n              console.log(r);\r\n              // console.log(r,r.text(),r.arrayBuffer());\r\n              return r.arrayBuffer();\r\n              //   return r.text();\r\n              //   return { text: r.text(), arraybuffer: r.arrayBuffer() };\r\n            })\r\n            .then(fetchhandler); */\r\n        }\r\n      } else {\r\n        console.log(\r\n          \"动态加载网页内容不刷新,不执行\" + \"原网页与现在的网址相同不刷新\",\r\n          document.firstElementChild.dataset.href,\r\n          url.href\r\n        );\r\n      }\r\n    }\r\n    // });\r\n  }\r\n\r\n  /**点击链接不跳转修改当前的网页地址动态加载网页内容不刷新 */\r\n})(\r\n  (typeof window != \"undefined\" && window) || this\r\n); /**点击链接不跳转修改当前的网页地址动态加载网页内容不刷新 */\r\n\r\n//  export default 修改当前的网页地址动态加载网页内容不刷新\r\n"]}