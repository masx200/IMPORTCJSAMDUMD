{"version":3,"file":"index.min.js","sources":["index.js"],"sourcesContent":["function createnullobj() {\n    return Object.create(null);\n}\n\nconst packagealias = createnullobj();\n\nconst packagestore = createnullobj();\n\nfunction getallmodules() {\n    return Object.entries(packagestore);\n}\n\nconst cacheurltocjsfun = createnullobj();\n\nconst concurrentimport = createnullobj();\n\nfunction promisedefer() {\n    let resolve = () => {};\n    let reject = () => {};\n    let promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise\n    };\n}\n\nconst asyncfun = new Function(\"return async function(){}\")();\n\nconst AsyncFunctionconstructor = Object.getPrototypeOf(asyncfun).constructor;\n\nasync function fetchtext(url) {\n    let codetype;\n    const cachedtext = get(cachedurltotext, url);\n    const cachedtype = get(cachedurltotype, url);\n    if (cachedtext && cachedtype) {\n        return [ cachedtext, cachedtype ];\n    } else {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"fetch failed \" + url);\n        }\n        const contenttype = response.headers.get(\"content-type\");\n        if (contenttype === null || contenttype === void 0 ? void 0 : contenttype.includes(\"javascript\")) {\n            codetype = \"js\";\n        } else if (contenttype === null || contenttype === void 0 ? void 0 : contenttype.includes(\"json\")) {\n            codetype = \"json\";\n        } else {\n            throw new Error(\"Invalid content-type: \" + contenttype);\n        }\n        const textsource = await response.text();\n        set(cachedurltotext, url, textsource);\n        set(cachedurltotype, url, codetype);\n        return [ textsource, codetype ];\n    }\n}\n\nconst cachedurltotext = createnullobj();\n\nconst cachedurltotype = createnullobj();\n\nconst cachemoduledeps = createnullobj();\n\nconst cachemoduletype = createnullobj();\n\nfunction ismodule(a) {\n    return {}.toString.call(a) === \"[object Module]\";\n}\n\nfunction isplainobject(o) {\n    return typeof o === \"object\" && {}.toString.call(o) === \"[object Object]\" && o instanceof Object && Reflect.getPrototypeOf(o) === Object.prototype;\n}\n\nfunction 定义default(target, def) {\n    var _a;\n    def = (_a = def === null || def === void 0 ? void 0 : def.default) !== null && _a !== void 0 ? _a : def;\n    if (!def) {\n        return;\n    }\n    if (!ismodule(def) && !isplainobject(def)) {\n        defineProperty(target, \"default\", {\n            enumerable: true,\n            get() {\n                return def;\n            }\n        });\n    }\n}\n\nfunction isArray(a) {\n    return Array.isArray(a) && {}.toString.call(a) === \"[object Array]\";\n}\n\nfunction define(name, deps, callback) {\n    if (typeof name !== \"string\") {\n        callback = deps;\n        deps = name;\n        name = null;\n    }\n    if (!isArray(deps)) {\n        callback = deps;\n        deps = null;\n    }\n    if (!deps) {\n        deps = [];\n    }\n    const defineglobalDefQueue = [ name, deps, callback ];\n    return defineglobalDefQueue;\n}\n\nclass cantfindError extends Error {\n    constructor(message, urlorname) {\n        super(message);\n        this.urlorname = urlorname;\n    }\n}\n\nfunction getmodule(packagename) {\n    assertstring(packagename);\n    const findpackage = packagestore[packagename] || packagestore[packagealias[packagename]];\n    if (findpackage) {\n        return findpackage;\n    } else {\n        throw new cantfindError(模块仓库中没有找到 + packagename, packagename);\n    }\n}\n\nfunction isurl(url) {\n    var flag = false;\n    try {\n        assertstring(url);\n        url = new URL(url).href;\n        flag = true;\n    } catch (error) {\n        flag = false;\n    }\n    return flag;\n}\n\nasync function 同时发起多个字符串(a, importcjsamdumd) {\n    return await Promise.all(a.map(e => importcjsamdumd(e)));\n}\n\nconst urlsymbol = Symbol(\"url\");\n\nconst 输入的类型错误输入的类型必须是字符串或者数组或对象 = \"The type entered is incorrect, the type entered must be a string or an array \";\n\nasync function oldimportcjsamdumd(url, packagename) {\n    var _a;\n    if (isArray(url)) {\n        const args = url;\n        let suoyouimportpromise = [];\n        const 传入参数arr = args;\n        try {\n            suoyouimportpromise = await 同时发起多个字符串(传入参数arr, oldimportcjsamdumd);\n        } catch (error) {\n            console.warn(error);\n            suoyouimportpromise = await 同时发起多个字符串(传入参数arr, oldimportcjsamdumd);\n        } finally {\n            suoyouimportpromise = await 同时发起多个字符串(传入参数arr, oldimportcjsamdumd);\n        }\n        return suoyouimportpromise;\n    } else if (typeof url === \"string\") {\n        assertstring(url);\n        try {\n            url = new URL(url).href;\n        } catch (_unused) {\n            url = (_a = packagealias[url]) !== null && _a !== void 0 ? _a : url;\n        }\n        if (String(url).startsWith(\"./\") || String(url).startsWith(\"../\")) {\n            var urlobj = new URL(url, location.href);\n            url = urlobj.origin + urlobj.pathname;\n        }\n        try {\n            url = new URL(url).href;\n        } catch (_unused2) {\n            throw Error(\"invalid url \" + url);\n        }\n        if (typeof packagename === \"undefined\") {\n            packagename = new URL(url).href;\n        }\n        if (packagename) {\n            packagealias[packagename] = url;\n        }\n        if (typeof packagestore[packagename] !== \"undefined\" && get(packagestore[packagename], urlsymbol) === url) {\n            return getmodule(packagename);\n        } else if (typeof packagestore[url] !== \"undefined\" && get(packagestore[url], urlsymbol) === url) {\n            return getmodule(url);\n        } else {\n            return await coreload(url);\n        }\n    } else {\n        throw new TypeError(输入的类型错误输入的类型必须是字符串或者数组或对象);\n    }\n}\n\nconst requirepackage = getmodule;\n\nconst 模块仓库中没有找到 = \"Cannot find module in packagestore, Not found in module repository, \";\n\nconst 参数必须为字符串 = \"Parameter must be a string\";\n\nconst 字符串不能为空 = \"String cannot be empty\";\n\nconst 补充加载依赖的模块网址 = \"补充加载依赖的模块网址\";\n\nasync function importcjsamdumd(url, packagename) {\n    let tryfailedtimes = 0;\n    return await oldimportcjsamdumd(url, packagename).catch(handleerror);\n    async function retryimport(url1, nam1, url2, name2) {\n        try {\n            await oldimportcjsamdumd(url1, nam1).catch(handleerror);\n            return await oldimportcjsamdumd(url2, name2);\n        } catch (error) {\n            console.warn(error);\n            return await oldimportcjsamdumd(url2, name2).catch(handleerror);\n        }\n    }\n    async function handleerror(e) {\n        console.warn(e);\n        if (tryfailedtimes > 5) {\n            throw new Error(\"Try loading, too many failures, give up trying!\" + JSON.stringify(url) + JSON.stringify(packagename));\n        }\n        tryfailedtimes++;\n        if (e instanceof cantfindError) {\n            const eurlorname = e.urlorname;\n            if (isurl(eurlorname)) {\n                console.log(补充加载依赖的模块网址, eurlorname);\n                return await retryimport(eurlorname, undefined, url, packagename);\n            } else {\n                throw e;\n            }\n        } else {\n            throw e;\n        }\n    }\n}\n\nfunction assertstring(s) {\n    if (s === \"\") {\n        throw new TypeError(字符串不能为空);\n    }\n    if (typeof s !== \"string\") {\n        throw new TypeError(参数必须为字符串);\n    }\n}\n\nfunction getnewimportpromise(url) {\n    const symbolkey = Symbol.for(\"import-\" + url);\n    return new Promise((resolve, reject) => {\n        const s = document.createElement(\"script\");\n        function clearsideeffect() {\n            removescript(s);\n            removeerrorlisten(errorhandler);\n            URL.revokeObjectURL(s.src);\n            s.onload = s.onerror = null;\n        }\n        function removeerrorlisten(f) {\n            try {\n                window.removeEventListener(\"error\", f);\n            } catch (error) {}\n        }\n        function removescript(e) {\n            e.remove();\n        }\n        function errorhandler(e) {\n            console.warn(e.error);\n            reject(e.error);\n            clearsideeffect();\n        }\n        window.addEventListener(\"error\", errorhandler);\n        const topLevelBlobUrl = createBlob(`import*as m from'${url}';\\nwindow[Symbol.for('${\"import-\" + url}')]=m`);\n        s.type = \"module\";\n        s.src = topLevelBlobUrl;\n        s.async = true;\n        s.onload = () => {\n            if (Reflect.has(window, symbolkey)) {\n                const moduleoutput = get(window, symbolkey);\n                resolve(moduleoutput);\n                set(window, symbolkey, undefined);\n                clearsideeffect();\n            }\n        };\n        s.onerror = () => {\n            reject(new Error(\"import load failed from network\" + url));\n            clearsideeffect();\n        };\n        document.head.appendChild(s);\n    });\n}\n\nfunction createBlob(source) {\n    return URL.createObjectURL(new Blob([ source ], {\n        type: \"application/javascript\"\n    }));\n}\n\nconst dynamicimportshimfun = (() => {\n    let dynamicimportshim;\n    try {\n        dynamicimportshim = Function(\"u\", \"return import(u)\");\n    } catch (error) {\n        dynamicimportshim = async function(url) {\n            assertstring(url);\n            url = new URL(url).href;\n            return await getnewimportpromise(url);\n        };\n    }\n    return dynamicimportshim;\n})();\n\nfunction isFunction(it) {\n    const op = {};\n    const ostring = op.toString;\n    const tag = ostring.call(it);\n    return \"function\" === typeof it && tag === \"[object Function]\" || tag === \"[object AsyncFunction]\";\n}\n\nfunction esmdefinegetter(moduleexport, exportdefault) {\n    if (exportdefault && (isFunction(exportdefault) || typeof exportdefault === \"object\")) {\n        Object.keys(exportdefault).forEach(key => {\n            try {\n                defineProperty(moduleexport, key, {\n                    enumerable: true,\n                    get() {\n                        return get(exportdefault, key);\n                    }\n                });\n            } catch (error) {}\n        });\n    }\n}\n\nconst myrequirefun = function requireinstead(packagename) {\n    var _a;\n    assertstring(packagename);\n    const findpackage = packagestore[packagename] || packagestore[packagealias[packagename]];\n    if (findpackage) {\n        return (_a = findpackage.default) !== null && _a !== void 0 ? _a : findpackage;\n    } else {\n        throw new cantfindError(模块仓库中没有找到 + packagename, packagename);\n    }\n};\n\nfunction getbaseurl(url) {\n    var objurl = new URL(url);\n    let path = new URL(\".\", objurl.href).href;\n    return path;\n}\n\nfunction 格式化url(baseurl, urlorname) {\n    if (String(urlorname).startsWith(\"./\") || String(urlorname).startsWith(\"../\")) {\n        if (!(String(urlorname).endsWith(\".js\") || urlorname.endsWith(\".mjs\") || urlorname.endsWith(\".json\") || urlorname.endsWith(\".css\") || urlorname.endsWith(\".html\"))) {\n            urlorname += \".js\";\n        }\n        urlorname = new URL(baseurl + urlorname).href;\n    }\n    return urlorname;\n}\n\nfunction getnormalizedurl(relativeurl, url) {\n    if (String(relativeurl).startsWith(\"./\") || String(relativeurl).startsWith(\"../\")) {\n        const baseurl = getbaseurl(url);\n        const formatedurl = 格式化url(baseurl, relativeurl);\n        return formatedurl;\n    } else {\n        return relativeurl;\n    }\n}\n\nconst formatedurlrequire = (urlorname, url) => {\n    assertstring(urlorname);\n    if (String(urlorname).startsWith(\"./\") || String(urlorname).startsWith(\"../\")) {\n        const formatedurl = getnormalizedurl(urlorname, url);\n        return myrequirefun(formatedurl);\n    } else {\n        return myrequirefun(urlorname);\n    }\n};\n\nfunction 非空对象(o) {\n    return !!(typeof o !== \"object\" || Object.keys(o).length || JSON.stringify(o) !== \"{}\");\n}\n\nfunction 处理非es模块(exportmodule) {\n    if (非空对象(exportmodule[0])) {\n        const exportdefault = exportmodule[0];\n        return exportdefault;\n    } else if (非空对象(exportmodule[1])) {\n        const exportdefault = exportmodule[1];\n        return exportdefault;\n    }\n}\n\nfunction isobject(a) {\n    return !!(a && typeof a === \"object\");\n}\n\nfunction mapaliastourl(arr) {\n    return arr.map(name => {\n        var _a;\n        if (isurl(name)) {\n            return name;\n        } else {\n            return (_a = packagealias[name]) !== null && _a !== void 0 ? _a : name;\n        }\n    });\n}\n\nfunction removerepetition(arr) {\n    return [ ...new Set(arr) ];\n}\n\nvar REQUIRE_RE = /\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|\\/\\*[\\S\\s]*?\\*\\/|\\/(?:\\\\\\/|[^\\/\\r\\n])+\\/(?=[^\\/])|\\/\\/.*|\\.\\s*require|(?:^|[^$])\\brequire\\s*\\(\\s*([\"'])(.+?)\\1\\s*\\)/g;\n\nvar SLASH_RE = /\\\\\\\\/g;\n\nfunction parseDependencies(code) {\n    var ret = [];\n    code.replace(SLASH_RE, \"\").replace(REQUIRE_RE, (function(m, m1, m2, ...args) {\n        if (m2) {\n            ret.push(m2);\n        }\n        return \"\";\n    }));\n    return ret;\n}\n\nfunction assert(con, msg) {\n    if (!con) {\n        throw TypeError(msg);\n    }\n}\n\nfunction checkDepsUrl(deps, url) {\n    deps.forEach(d => {\n        assert(isurl(d), \"unresolved dependency:\" + d + \",in module:\" + url);\n    });\n}\n\nasync function 主核心加载模块函数(url, resolve, reject) {\n    var _a;\n    const dependents = new Set;\n    set(cachemoduledeps, url, dependents);\n    try {\n        let fetchpromisetext;\n        let codetype;\n        try {\n            [fetchpromisetext, codetype] = await fetchtext(url);\n        } catch (e) {\n            console.warn(e);\n            reject(e);\n            return;\n        }\n        const moduleexport = createnullobj();\n        defineProperty(moduleexport, urlsymbol, {\n            value: url\n        });\n        let moduletype;\n        const scripttext = fetchpromisetext;\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n            defineProperty(moduleexport, Symbol.toStringTag, {\n                value: \"Module\"\n            });\n        }\n        if (\"json\" === codetype) {\n            const moduleexportdefault = JSON.parse(scripttext);\n            moduletype = \"json\";\n            if (moduleexportdefault) {\n                if (isplainobject(moduleexportdefault)) {\n                    esmdefinegetter(moduleexport, moduleexportdefault);\n                } else {\n                    定义default(moduleexport, moduleexportdefault);\n                }\n            }\n            set(cachemoduletype, url, moduletype);\n            packagestore[url] = moduleexport;\n            resolve(moduleexport);\n            return;\n        } else if (\"js\" === codetype) {\n            try {\n                const exports_exports = {\n                    [Symbol.toStringTag]: \"Module\"\n                };\n                const module = {\n                    exports: {\n                        [Symbol.toStringTag]: \"Module\"\n                    }\n                };\n                try {\n                    let isamd = false;\n                    const funparams = [ \"require\", \"exports\", \"module\", \"define\" ];\n                    const funbody = `\"use strict\";\\n/* ${url} */;\\n;${scripttext};\\n;/* ${url} */;\\n`;\n                    const 模块加载函数 = (_a = get(cacheurltocjsfun, url)) !== null && _a !== void 0 ? _a : new AsyncFunctionconstructor(...funparams, funbody);\n                    set(cacheurltocjsfun, url, 模块加载函数);\n                    const cjsmoduleexportdeps = removerepetition(mapaliastourl(parseDependencies(scripttext).map(urlorname => getnormalizedurl(urlorname, url))));\n                    cjsmoduleexportdeps.forEach(d => {\n                        dependents.add(d);\n                    });\n                    checkDepsUrl(cjsmoduleexportdeps, url);\n                    await importcjsamdumd(cjsmoduleexportdeps);\n                    let amdfactory = () => {};\n                    const require_require = name => formatedurlrequire(name, url);\n                    const amddeps = [];\n                    const define_define = (name, deps, callback) => {\n                        const defineglobalDefQueue = define(name, deps, callback);\n                        isamd = true;\n                        amdfactory = defineglobalDefQueue[2];\n                        const moduleexportdeps = removerepetition(mapaliastourl(defineglobalDefQueue[1].map(urlorname => getnormalizedurl(urlorname, url))));\n                        amddeps.push(...moduleexportdeps);\n                        moduleexportdeps.forEach(d => dependents.add(d));\n                    };\n                    Object.assign(define_define, {\n                        amd: true,\n                        cmd: true\n                    });\n                    await 模块加载函数.call(module.exports, require_require, exports_exports, module, define_define);\n                    if (isamd) {\n                        moduletype = \"amd\";\n                        const moduleexportdeps = [ ...amddeps ];\n                        checkDepsUrl(moduleexportdeps, url);\n                        await importcjsamdumd(moduleexportdeps);\n                        let amdcallargs;\n                        if (moduleexportdeps.length) {\n                            amdcallargs = moduleexportdeps.map(e => myrequirefun(e));\n                        } else {\n                            amdcallargs = [ require_require, exports_exports, module ];\n                        }\n                        let define_exports;\n                        if (isFunction(amdfactory)) {\n                            define_exports = amdfactory.call(module.exports, ...amdcallargs);\n                        } else if (isobject(amdfactory)) {\n                            define_exports = amdfactory;\n                        }\n                        define_exports = await define_exports;\n                        !!define_exports && (module.exports = define_exports);\n                    } else {\n                        moduletype = \"cjs\";\n                    }\n                    !module.exports && (module.exports = {\n                        [Symbol.toStringTag]: \"Module\"\n                    });\n                    const exportmodule = [ exports_exports, module.exports ];\n                    const usefulexport = await 处理非es模块(exportmodule);\n                    if (usefulexport) {\n                        定义default(moduleexport, usefulexport);\n                        esmdefinegetter(moduleexport, usefulexport);\n                    }\n                } catch (e) {\n                    console.warn(e);\n                    if (e instanceof SyntaxError) {\n                        const topLevelBlobUrl = url;\n                        try {\n                            const exportdefault = await dynamicimportshimfun(topLevelBlobUrl);\n                            moduletype = \"esm\";\n                            esmdefinegetter(moduleexport, exportdefault);\n                        } catch (e) {\n                            console.warn(e);\n                            reject(e);\n                            return;\n                        }\n                    } else {\n                        console.warn(e);\n                        reject(e);\n                        return;\n                    }\n                }\n                set(cachemoduletype, url, moduletype);\n                packagestore[url] = moduleexport;\n                if (moduleexport.default) {\n                    esmdefinegetter(moduleexport, moduleexport.default);\n                }\n                if (Object.keys(moduleexport).length === 0) {\n                    defineProperty(moduleexport, \"default\", {\n                        value: {},\n                        enumerable: true\n                    });\n                }\n                resolve(moduleexport);\n                return;\n            } catch (e) {\n                console.warn(e);\n                reject(e);\n                return;\n            }\n        } else {\n            throw new Error(\"invalid codetype \" + codetype);\n        }\n    } catch (e) {\n        console.warn(e);\n        reject(e);\n        return;\n    }\n}\n\nconst {get: get, set: set, defineProperty: defineProperty} = Reflect;\n\nconst timeout = 10 * 1e3;\n\nasync function coreload(url) {\n    return new Promise(async (resolve, reject) => {\n        var _a;\n        setTimeout(() => {\n            reject(new Error(\"import module timeout:\" + url));\n        }, timeout);\n        const loadpro = (_a = concurrentimport === null || concurrentimport === void 0 ? void 0 : concurrentimport[url]) === null || _a === void 0 ? void 0 : _a.promise;\n        if (loadpro) {\n            resolve(Promise.resolve(loadpro));\n            return;\n        } else {\n            const defered = promisedefer();\n            concurrentimport[url] = defered;\n            try {\n                const module = await new Promise((resolve, reject) => 主核心加载模块函数(url, resolve, reject));\n                defered.resolve(module);\n                resolve(module);\n                return;\n            } catch (e) {\n                defered.reject(e);\n                setTimeout(() => {\n                    Reflect.set(concurrentimport, url, undefined);\n                }, 0);\n                console.warn(e);\n                reject(e);\n                return;\n            }\n        }\n    });\n}\n\nfunction getmodulewrapper(url) {\n    assertstring(url);\n    return get(cacheurltocjsfun, url);\n}\n\nfunction getmoduledeps(url) {\n    assertstring(url);\n    const deps = get(cachemoduledeps, url);\n    if (deps) {\n        return [ ...deps ];\n    }\n    return;\n}\n\nfunction getmoduleids() {\n    return Object.keys(packagestore);\n}\n\nfunction getmodulesource(url) {\n    assertstring(url);\n    return get(cachedurltotext, url);\n}\n\nfunction getmoduletype(url) {\n    assertstring(url);\n    return get(cachemoduletype, url);\n}\n\nconst dynamicimport = importcjsamdumd;\n\nexport default importcjsamdumd;\n\nexport { dynamicimport, getallmodules, getmoduledeps, getmoduleids, getmodulesource, getmoduletype, getmodulewrapper, packagealias, requirepackage };\n//# sourceMappingURL=index.js.map\n"],"names":["Object","create"],"mappings":"oBACWA,OAAOC,OAAO"}